{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"@State"},{"type":"text","text":" allows for the developer to keep a state across multiple events, e.g. multiple messages that are part of the same connection. "},{"type":"codeVoice","code":"@State"},{"type":"text","text":" variables require a default value to be defined by the developer (except the "},{"type":"codeVoice","code":"wrappedValue"},{"type":"text","text":" is of an optional type). The "},{"type":"codeVoice","code":"wrappedValue"},{"type":"text","text":" has a setter."}]},{"anchor":"Lifetime","level":2,"type":"heading","text":"Lifetime"},{"anchor":"Influence","level":3,"type":"heading","text":"Influence"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The presence of "},{"type":"codeVoice","code":"@State"},{"type":"text","text":" properties on a "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" signalizes exporting the endpoint as a Client-Side Stream makes sense. If the exporter decides to do so the lifetime of the "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" has to be extended accordingly."}]},{"anchor":"Implementation-Details","level":3,"type":"heading","text":"Implementation-Details"},{"anchor":"Request-Response","level":4,"type":"heading","text":"Request-Response"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If an exporter only supports the Request-Response pattern it should export all "},{"type":"codeVoice","code":"@Parameter var x: T"},{"type":"text","text":" as an array of type T. The arrays should be of same length for all parameters. The exporter then injects the elements for one index after another until either the evaluation of the "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" results in anything but "},{"type":"codeVoice","code":".nothing"},{"type":"text","text":" or the end of the arrays is reached. The second case would result in an error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A possible exception could be made for identifying parameters because representing those as an array could be difficult for some exporters and it seems very unlikely that one would like to stream identifiers."}]},{"anchor":"Client-Side-Stream","level":4,"type":"heading","text":"Client-Side Stream"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After the initial request to the endpoint the "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" is kept alive and waits for further incoming messages. The "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" is evaluated for each incoming message until the "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":"â€™s logic comes to a state where it decides to return something else than "},{"type":"codeVoice","code":".nothing"},{"type":"text","text":". Afterwards the "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" can be destructed."}]},{"anchor":"Service-Side-Stream","level":4,"type":"heading","text":"Service-Side Stream"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The handling of the request should be similar to the one for Request-Response pattern."}]},{"anchor":"Bidirectional-Stream","level":4,"type":"heading","text":"Bidirectional Stream"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The handling of incoming messages should be similar to the one for the Client-Side Stream pattern. The "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" is destructed when it evaluates to either "},{"type":"codeVoice","code":".end"},{"type":"text","text":" or "},{"type":"codeVoice","code":".final(E)"},{"type":"text","text":"."}]},{"anchor":"Control-Flow","level":2,"type":"heading","text":"Control Flow"},{"anchor":"Influence","level":3,"type":"heading","text":"Influence"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"@State"},{"type":"text","text":"s do not emit their own events."}]},{"anchor":"Implementation-Details","level":3,"type":"heading","text":"Implementation Details"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The evaluation of "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" based on a certain event may never observe changes on an "},{"type":"codeVoice","code":"@State"},{"type":"text","text":" that are not caused by the same evaluation."}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/apodini\/meaningofstate"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Apodini\/documentation\/Apodini\/MeaningOfState","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Description of State property wrapper and its usage in Apodini."}],"kind":"article","metadata":{"roleHeading":"Article","title":"State","role":"article","modules":[{"name":"Apodini"}]},"hierarchy":{"paths":[["doc:\/\/Apodini\/documentation\/Apodini","doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern","doc:\/\/Apodini\/documentation\/Apodini\/Tooling"]]},"seeAlsoSections":[{"title":"Tooling","identifiers":["doc:\/\/Apodini\/documentation\/Apodini\/MeaningOfParameter","doc:\/\/Apodini\/documentation\/Apodini\/MeaningOfObservedObject","doc:\/\/Apodini\/documentation\/Apodini\/MeaningOfEnvironment"],"generated":true}],"references":{"doc://Apodini/documentation/Apodini":{"role":"collection","title":"Apodini","abstract":[{"type":"text","text":"A declarative, composable framework to build web services using Swift."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini","kind":"symbol","type":"topic","url":"\/documentation\/apodini"},"doc://Apodini/documentation/Apodini/MeaningOfParameter":{"role":"article","title":"Parameter","abstract":[{"type":"text","text":"Specifying input for endpoints with Parameter property wrapper in Apodini."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/MeaningOfParameter","kind":"article","type":"topic","url":"\/documentation\/apodini\/meaningofparameter"},"doc://Apodini/documentation/Apodini/MeaningOfObservedObject":{"role":"article","title":"ObservedObject","abstract":[{"type":"text","text":"Description of ObservedObject property wrapper and its usage in Apodini."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/MeaningOfObservedObject","kind":"article","type":"topic","url":"\/documentation\/apodini\/meaningofobservedobject"},"doc://Apodini/documentation/Apodini/CommunicationPattern":{"role":"collectionGroup","title":"Communication Pattern","abstract":[{"type":"text","text":"Communication patterns and their usage in different client-service protocols."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern","kind":"article","type":"topic","url":"\/documentation\/apodini\/communicationpattern"},"doc://Apodini/documentation/Apodini/MeaningOfEnvironment":{"role":"collectionGroup","title":"Environment","abstract":[{"type":"text","text":"Description of Environment property wrapper and its usage in Apodini."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/MeaningOfEnvironment","kind":"article","type":"topic","url":"\/documentation\/apodini\/meaningofenvironment"},"doc://Apodini/documentation/Apodini/Tooling":{"role":"collectionGroup","title":"Tooling","abstract":[{"type":"text","text":"Description service structure for endpoints."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Tooling","kind":"article","type":"topic","url":"\/documentation\/apodini\/tooling"}}}