{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Summary","level":2,"type":"heading","text":"Summary"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The APIs described in this document are used to access, from within a handler’s "},{"type":"codeVoice","code":"handle()"},{"type":"text","text":" function, the functionality provided by another handler"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"InvocableHandler"},{"type":"text","text":" protocol, which inherits from "},{"type":"codeVoice","code":"IdentifiableHandler"},{"type":"text","text":", is used to denote "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":"s which can be remotely invoked (ie, from within a "},{"type":"codeVoice","code":"Handler.handle()"},{"type":"text","text":" function)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"RemoteHandlerInvocationManager"},{"type":"text","text":" type implements a helper object which is responsible for coordinating inter-component communication"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This helper object (you can think of this as a kind of mediator) has knowledge of the web service’s structure and use that to determine how to realise interactions between handlers"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The API as currenly defined only supports invoking components which use the request-response communication pattern"}]}]}]},{"anchor":"The-InvocableHandler-protocol","level":2,"type":"heading","text":"The `InvocableHandler` protocol"},{"type":"codeListing","syntax":"swift","code":["public protocol InvocableHandler: IdentifiableHandler where Response: Decodable {","    typealias ParametersStorageProtocol = InvocableHandlerParametersStorageProtocol","    associatedtype ParametersStorage: ParametersStorageProtocol = _EmptyParametersStorage<Self> where ParametersStorage.HandlerType == Self","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"codeVoice","code":"InvocableHandler"},{"type":"text","text":" is an "},{"type":"codeVoice","code":"IdentifiableHandler"},{"type":"text","text":" whose "},{"type":"codeVoice","code":"Response"},{"type":"text","text":" type conforms to "},{"type":"codeVoice","code":"Decodable"},{"type":"text","text":", and which optionally defines a custom type for passing parameters to a remote invocation (see below for an explanation of how parameter passsing works)."}]},{"anchor":"Defining-and-using-invocable-handlers","level":2,"type":"heading","text":"Defining and using invocable handlers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Simple example of a handler which accesses another handler’s functionality."}]},{"type":"codeListing","syntax":"swift","code":["struct RandomNumberGenerator: InvocableHandler {","    class HandlerIdentifier: ScopedHandlerIdentifier<RandomNumberGenerator> {","        static let main = HandlerIdentifier(\"main\")","    }","    let handlerId = HandlerIdentifier.main","    ","    @Parameter var lowerBound: Int","    @Parameter var upperBound: Int","    ","    func handle() -> Int {","        Int.ramdom(in: lowerBound..<upperBound)","    }","}","","","struct Greeter: Handler {","    private var RHI = RemoteHandlerInvocationManager()","    ","    @Parameter var name: String","    ","    func handle() async throws -> String {","        let number = try await RHI.invoke(","            RandomNumberGenerator.self,","            identifiedBy: .main,","            parameters: [","                .init(\\.$lowerBound, 0),","                .init(\\.$upperBound, name.length)","            ]","        )","        return \"Hello, \\(name)! Your lucky number is \\(number).\"","    }","}"]},{"anchor":"The-Remote-Invocation-Manager","level":2,"type":"heading","text":"The Remote Invocation Manager"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The invocation manager acts as a mediator overseeing all inter-handler interactions for a handler. Each handler which wants to interact with other handlers defines its own instance of the invocation manager."}]},{"anchor":"Whats-an-interaction","level":3,"type":"heading","text":"What’s an interaction?"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An interaction is an event where date are transferred between two handlers, and which was initiated within one of the two handler’s "},{"type":"codeVoice","code":"handle()"},{"type":"text","text":" functions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An interaction consists of the following parts:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"sender: the component type which initiated the interaction. This can be any "},{"type":"codeVoice","code":"Handler"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"target: the component type the sender component is trying to invoke. This must be an "},{"type":"codeVoice","code":"InvocableHandler"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"target identifier: the identifier of the target component"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An interaction may be one-way (ie, the target doesn’t send a response, or the response is discarded by the invocation manager), and the target does not necessarily know if it is being accessed by another handler (via the invocation manager) or by a “normal” client."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Broadly speaking, we differentiate between two kinds of interactions:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Local (in-process) interactions"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"These are interactions where sender and target are running in the same process"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, the interaction is dispatched locally, ie the target endpoint’s "},{"type":"codeVoice","code":"handle()"},{"type":"text","text":" function executed on the current event loop"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remote (out-of-process) interactions"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"These are interactions where sender and target are running in different processed (potentially even on different machines and different networks)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Remote interactions are available when running a web service as a distributed system (ie, a system of distinct nodes, each of which implement a subset of the web service’s exported endpoints)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, the interaction is realised by finding the correct node within our distributed system, invoking the target component there, and returning the result back to the sender"}]}]}]}]}]},{"anchor":"What-does-the-invocation-manager-do","level":3,"type":"heading","text":"What does the invocation manager do?"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The invocation manager is responsible for deciding whether the target component should be invoked locally or remotely, thus acting as a dispatcher. It is also responsible for realising the interaction."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The invocation manager has access to the full structure of the web service (eg via the "},{"type":"codeVoice","code":"WebServiceModel"},{"type":"text","text":" object) and the deployment structure (ie information about the number of processes running the web service, the endpoints implemented by each process, etc)."},{"type":"text","text":" "},{"type":"text","text":"It uses these data to determine how to best dispatch individual invocations."},{"type":"text","text":" "},{"type":"text","text":"A handler’s invocation manager is dynamically detected and provided this information, similarly to how "},{"type":"codeVoice","code":"RequestInjectable"},{"type":"text","text":"s are handled."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Based on this information, the invocation manager will:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"locate the target handler"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"encapsulate the parameters (and other relevant data) into a "},{"type":"codeVoice","code":"Request"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"send that request to the target handler"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"wait for the target handler to finish and return a response"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"decode that response into the (statically known) target handler’s response type"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"return the response object back to the sender"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Note:"}]},{"type":"text","text":" Steps 2 through 4 might differ based on the deployed-to platform: whereas when running as a HTTP server on localhost we might simply send a HTTP request to the target (thus essentially emulating a client), on platforms like AWS Lambda it might be a better idea to use platform-provided APIs to directly invoke the target handler."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"invoke"},{"type":"text","text":" function is an async function, since the invocation might be dispatched locally or remotely. For locally dispatched interactions, the returned future will always be succeeded, and contain the value returned by the invoked components’ handle function."}]},{"anchor":"The-remote-invocation-API","level":2,"type":"heading","text":"The remote-invocation API"},{"type":"codeListing","syntax":"swift","code":["func invoke<H: InvocableHandler>(","    _: H.Type,","    identifiedBy handlerId: H.HandlerIdentifier,","    arguments: [CollectedArgument<H>] = []",") async throws -> H.Response.Content"]},{"anchor":"Return-values","level":2,"type":"heading","text":"Return values"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The remote-invocation API features async "},{"type":"codeVoice","code":"invoke"},{"type":"text","text":" functions."},{"type":"text","text":" "},{"type":"text","text":"Since invocations may be dispatched either locally or remotely, there is no guarantee as to whether an invocation is realised synchronous or asynchronous."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The returned object is the decoded response from the invoked handler. (This is the reason for the "},{"type":"codeVoice","code":"where Response: Decodable"},{"type":"text","text":" constraint on the "},{"type":"codeVoice","code":"InvocableHandler"},{"type":"text","text":" protocol.)"}]},{"anchor":"Parameters","level":2,"type":"heading","text":"Parameters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When invoking another handler, the values of the parameters expected by the invoked handler (ie, its "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":" properties) must be specified by the caller."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Parameters for a remote invocation are 2-tuples consisting of a key path into the invoked handler (ie, a key path identifying the "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":" the value belongs to) to the value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There are two ways parameters can be specified:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An invocable handler can define what its remote-invocation parameters should be, and how they should be mapped to its "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":" properties"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"An invocable handler can let Apodini take care of the mapping. (This is the default behaviour)"}]}]}]},{"anchor":"1-Using-a-dedicated-ParametersStorage-type-nested-in-the-invoked-handler","level":3,"type":"heading","text":"1. Using a dedicated `ParametersStorage` type nested in the invoked handler"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"InvocableHandler"},{"type":"text","text":" protocol defines an (optional) associated type "},{"type":"codeVoice","code":"ParametersStorage"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"A Handler can implement this type to provide a custom storage object for parameter values."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For handlers defining a parameter storage type, the remote-invocation API is as follows:"}]},{"type":"codeListing","syntax":"swift","code":["func invoke<H: InvocableHandler>(","    _: H.Type,","    identifiedBy handlerId: H.HandlerIdentifier,","    arguments: H.ArgumentsStorage",") async throws -> H.Response.Content"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The parameters storage type consists of two things:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"properties for the parameters which should be passed to the Handler"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"a mapping from the "},{"type":"codeVoice","code":"ParametersStorage"},{"type":"text","text":" properties to the Handler’s "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":"s"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"mapping"},{"type":"text","text":" static property is an array instructing the remote-invocation manager how the parameter storage’s properties should be mapped to the Handler’s "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":"s."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a Handler provides the "},{"type":"codeVoice","code":"ParametersStorage"},{"type":"text","text":" type, the remote-invocation API can only be used by passing an instance of this type. This gives the invoked handler full control over how its parameters should be passed. It also means that invalid remote-invocation parameters (eg: missing parameters, incorrect types, etc) can be caught at compile-time."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The benefit of the "},{"type":"codeVoice","code":"ParametersStorage"},{"type":"text","text":" approach is that the handler can exercise control over how the remote-invocation API should process its parameters."},{"type":"text","text":" "},{"type":"text","text":"The downside is that the handler has to write boilerplate code, which needs to be kept in sync with its "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":"s."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Example"}]}]},{"type":"codeListing","syntax":"swift","code":["struct RandomNumberGenerator: InvocableHandler {","    struct ParametersStorage: ParametersStorageProtocol {","        typealias HandlerType = RandomNumberGenerator","        ","        let lowerBound: Int","        let upperBound: Int","        ","        static let mapping: [MappingEntry] = [","            .init(from: \\.lowerBound, to: \\.$lowerBound),","            .init(from: \\.upperBound, to: \\.$upperBound)","        ]","    }","    ","    class HandlerIdentifier: ScopedHandlerIdentifier<RandomNumberGenerator> {","        static let main = HandlerIdentifier(\"main\")","    }","    let handlerId = HandlerIdentifier.main","    ","    @Parameter var lowerBound: Int","    @Parameter var upperBound: Int","    ","    func handle() -> Int {","        guard lowerBound <= upperBound else {","            return 0","        }","        return Int.random(in: lowerBound..<upperBound)","    }","}"]},{"anchor":"2-Array-based-parameter-passing","level":3,"type":"heading","text":"2. Array-based parameter passing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If an "},{"type":"codeVoice","code":"InvocableHandler"},{"type":"text","text":" does not specify a "},{"type":"codeVoice","code":"ParametersStorage"},{"type":"text","text":" type, the remote-invocation API instead expects an array of keypath-value mappings:"}]},{"type":"codeListing","syntax":"swift","code":["func invoke<H: InvocableHandler>(","    _: H.Type,","    identifiedBy handlerId: H.HandlerIdentifier,","    arguments: [CollectedArgument<H>] = []",") async throws -> H.Response.Content"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Where "},{"type":"codeVoice","code":"CollectedParameter"},{"type":"text","text":" is a struct storing:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"a key path to an "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":" within an invocable handler"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"the value which should be passed for this parameter"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"("},{"type":"codeVoice","code":"_EmptyParametersStorage "},{"type":"text","text":" is a non-initialisable type which a Handler can use to opt in to the array-based parameter passing. For "},{"type":"codeVoice","code":"InvocableHandler"},{"type":"text","text":"s which do not specify a "},{"type":"codeVoice","code":"ParametersStorage"},{"type":"text","text":" type, the parameter storage defaults to this type.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similar to how the "},{"type":"codeVoice","code":"ParametersStorage"},{"type":"text","text":" consisted of the parameter values alongside an array mapping the key path to a value (within the parameters storage) to the key path of its respective "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":" (within the Handler), the "},{"type":"codeVoice","code":"CollectedParameter"},{"type":"text","text":"s expected by this function consist of the parameter value and the key path to the handler’s "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Entries for "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":"s which define a default value may be omitted from the parameters array."},{"type":"text","text":" "},{"type":"text","text":"If the parameters array contains multiple entries for the same "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":" key path, the last one is used."},{"type":"text","text":" "},{"type":"text","text":"Incomplete parameter lists (eg missing parameters) result in a run-time error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The advantage of this parameter-passing approach is that the handler doesn’t have to write boilerplate code."},{"type":"text","text":" "},{"type":"text","text":"The downside, however, is the loss of compile-time well-formedness checking."}]},{"anchor":"A-more-complex-example","level":2,"type":"heading","text":"A more complex example"},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Apodini","import NIO","","","","struct User: Codable {","    let name: String","    let email: String","    let age: Int","}","","","var users: [UUID: User] = [:]","","","struct CreateUser: InvocableHandler {","    class HandlerIdentifier: ScopedHandlerIdentifier<CreateUser> {","        static let main = HandlerIdentifier(\"main\")","    }","    let handlerId = HandlerIdentifier.main","    ","    @Parameter(.http(.body))","    var user: User","    ","    func handle() -> UUID {","        let id = UUID()","        users[id] = user","        return id","    }","}","","","struct GetUser: InvocableHandler {","    class HandlerIdentifier: ScopedHandlerIdentifier<GetUser> {","        static let main = HandlerIdentifier(\"main\")","    }","    let handlerId = HandlerIdentifier.main","    ","    @Parameter var id: UUID","    ","    func handle() -> User? {","        users[id]","    }","}","","","struct RandomStringGenerator: InvocableHandler {","    private static let alphanumerics = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"","    ","    class HandlerIdentifier: ScopedHandlerIdentifier<RandomStringGenerator> {","        static let main = HandlerIdentifier(\"main\")","    }","    let handlerId = HandlerIdentifier.main","    ","    @Parameter var length: Int","    ","    func handle() -> String {","        String((0..<length).compactMap { _ in Self.alphanumerics.randomElement() })","    }","}","","","struct RandomNumberGenerator: InvocableHandler {","    struct ParametersStorage: ParametersStorageProtocol {","        typealias HandlerType = RandomNumberGenerator","        let lowerBound: Int","        let upperBound: Int","        static let mapping: [MappingEntry] = [","            .init(from: \\.lowerBound, to: \\.$lowerBound),","            .init(from: \\.upperBound, to: \\.$upperBound)","        ]","    }","    ","    class HandlerIdentifier: ScopedHandlerIdentifier<RandomNumberGenerator> {","        static let main = HandlerIdentifier(\"main\")","    }","    let handlerId = HandlerIdentifier.main","    ","    @Parameter var lowerBound: Int = 52","    @Parameter var upperBound: Int = 52","    ","    func handle() -> Int {","        guard lowerBound <= upperBound else {","            return 0","        }","        return Int.random(in: lowerBound..<upperBound)","    }","}","","","struct Greeter: Handler {","    private var RHI = RemoteHandlerInvocationManager()","    ","    @Parameter var name: String","    ","    init(name: Parameter<String>) {","        _name = name","    }","    ","    func handle() async throws -> String {","        let randomNumber = try await RHI.invoke(","            RandomNumberGenerator.self,","            identifiedBy: .main,","            parameters: .init(lowerBound: 0, upperBound: 12)","        )","        let randomString = try await RHI.invoke(","            RandomStringGenerator.self,","            identifiedBy: .main,","            parameters: [.init(\\.$length, randomNumber)]","        )","        let userId = try await RHI.invoke(","            CreateUser.self,","            identifiedBy: .main,","            parameters: [.init(\\.$user, User(name: name, email: \"\\(randomString)@gmail\", age: 22))]","        )","        let user = try await RHI.invoke(","            GetUser.self,","            identifiedBy: .main,","            parameters: [.init(\\.$id, userId)]","        )","        return \"Hello, \\(name). Your user account is \\(user)\"","    }","}","","","struct WebService: Apodini.WebService {","    @PathParameter var name: String","    ","    var content: some Component {","        Text(\"welcome at the root level\")","        Group(\"greet\", $name) {","            Greeter(name: $name)","        }","        Group(\"random\") {","            Group(\"int\") {","                RandomNumberGenerator()","            }","            Group(\"string\") {","                RandomStringGenerator()","            }","        }","        Group(\"api\") {","            Group(\"user\") {","                CreateUser().operation(.create)","                GetUser().operation(.read)","            }","        }","    }","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/apodini\/inter-component-communication"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Apodini\/documentation\/Apodini\/Inter-Component-Communication","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Web services deployed with Apodini Deployer can be distributed across different nodes. Inter-component communication enables the communication between components between these nodes."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Inter-Component Communication","role":"article","modules":[{"name":"Apodini"}]},"hierarchy":{"paths":[["doc:\/\/Apodini\/documentation\/Apodini"]]},"seeAlsoSections":[{"title":"Advanced","identifiers":["doc:\/\/Apodini\/documentation\/Apodini\/BuildingExporters","doc:\/\/Apodini\/documentation\/Apodini\/HandlerDelegation","doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern","doc:\/\/Apodini\/documentation\/Apodini\/ProtocolBuffers","doc:\/\/Apodini\/documentation\/Apodini\/ExporterConfiguration","doc:\/\/Apodini\/documentation\/Apodini\/RetrieveRelationship","doc:\/\/Apodini\/documentation\/Apodini\/DSLComponents","doc:\/\/Apodini\/documentation\/Apodini\/Semantic-Model"],"generated":true}],"references":{"doc://Apodini/documentation/Apodini/ExporterConfiguration":{"role":"collectionGroup","title":"Configuration of Exporters","abstract":[{"type":"text","text":"Extensive configuration options for Apodini Exporters."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/ExporterConfiguration","kind":"article","type":"topic","url":"\/documentation\/apodini\/exporterconfiguration"},"doc://Apodini/documentation/Apodini/RetrieveRelationship":{"role":"collectionGroup","title":"Retrieving Relationship Information","abstract":[{"type":"text","text":"This proposal describes how relationship information can be generated from the DSL, introduces some concepts"},{"type":"text","text":" "},{"type":"text","text":"to give hints for relationship retrieval and adds mechanisms to manually define hints."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/RetrieveRelationship","kind":"article","type":"topic","url":"\/documentation\/apodini\/retrieverelationship"},"doc://Apodini/documentation/Apodini/InterfaceExporter":{"role":"symbol","title":"InterfaceExporter","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"InterfaceExporter"}],"abstract":[{"type":"text","text":"An "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter"},{"type":"text","text":" is a type which requires access to the web service’s structure and"},{"type":"text","text":" "},{"type":"text","text":"internals."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"InterfaceExporter"}],"url":"\/documentation\/apodini\/interfaceexporter"},"doc://Apodini/documentation/Apodini/DSLComponents":{"role":"collectionGroup","title":"DSL Components","abstract":[{"type":"text","text":"Apodini DSL central building blocks."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/DSLComponents","kind":"article","type":"topic","url":"\/documentation\/apodini\/dslcomponents"},"doc://Apodini/documentation/Apodini/Semantic-Model":{"role":"collectionGroup","title":"Semantic Model","abstract":[{"type":"text","text":"The semantic model is an intermediary model that is somewhere in the middle between the web service declaration you write using the Apodini DSL and the behavior of the web service."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Semantic-Model","kind":"article","type":"topic","url":"\/documentation\/apodini\/semantic-model"},"doc://Apodini/documentation/Apodini/CommunicationPattern":{"role":"collectionGroup","title":"Communication Pattern","abstract":[{"type":"text","text":"Communication patterns and their usage in different client-service protocols."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern","kind":"article","type":"topic","url":"\/documentation\/apodini\/communicationpattern"},"doc://Apodini/documentation/Apodini/HandlerDelegation":{"role":"collectionGroup","title":"Delegating Handlers","abstract":[{"type":"text","text":"Defining reusable and assertive "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":"s."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/HandlerDelegation","kind":"article","type":"topic","url":"\/documentation\/apodini\/handlerdelegation"},"doc://Apodini/documentation/Apodini/BuildingExporters":{"role":"collectionGroup","title":"Building Exporters","abstract":[{"type":"text","text":"Writing a web service with Apodini is easy - as long as there are "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter"},{"type":"text","text":"s suitable for your purposes. If that is not the case, you might need to adapt one, or build a new one."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/BuildingExporters","kind":"article","type":"topic","url":"\/documentation\/apodini\/buildingexporters"},"doc://Apodini/documentation/Apodini/ProtocolBuffers":{"role":"collectionGroup","title":"Protocol Buffers","abstract":[{"type":"text","text":"Describe how to export the webservice via IDL exporter."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/ProtocolBuffers","kind":"article","type":"topic","url":"\/documentation\/apodini\/protocolbuffers"},"doc://Apodini/documentation/Apodini":{"role":"collection","title":"Apodini","abstract":[{"type":"text","text":"A declarative, composable framework to build web services using Swift."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini","kind":"symbol","type":"topic","url":"\/documentation\/apodini"}}}