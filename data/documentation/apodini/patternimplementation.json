{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Apodini enables the developer to describe a functionality for a certain endpoint using "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"s. Apodini’s exporters try to export as much as possible of this functionality using the toolset provided by their respective protocols. In certain cases the protocol does not support all of the functionality described in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":". That is when Apodini has to downgrade the functionality to fit the protocol’s restrictions. Apodini automatically tries to find an alternative representation in the incompatible protocol so that the exported service does not become dysfunctional. Of course, the developer should be able to choose the exported pattern for each exporter individually if the automatic choice does not meet their needs."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the rare cases where that is not possible, the developer may decide to hide this incompatible endpoint from a specific exporter on a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"-level and provide an alternative implementation that is compatible with a more basic communication pattern."}]},{"anchor":"Support","level":2,"type":"heading","text":"Support"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the future, the developer should be able to use Apodini’s tooling without thinking about communication patterns and what protocols they want to support and still end up with fully functional services from all exporters."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Currently, most exporters do not support all communication patterns:"}]},{"type":"table","rows":[[[{"type":"paragraph","inlineContent":[]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Request-Response"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Client-Side Stream"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Service-Side Stream"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"Bidirectional Stream"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"RESTful"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"gRPC"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"WebSocket"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"GraphQL"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"❌"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"HTTP"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"✅"}]}]]],"header":"row"},{"anchor":"HTTP-Streaming","level":3,"type":"heading","text":"HTTP Streaming"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Streaming via the HTTP interface exporter is implemented in two ways. Via HTTP\/1.1, array-based streaming is available. Via HTTP\/2, dynamic streaming is supported via HTTP\/2 streams."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"HTTP\/1.1 Array-based Streaming"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Multiple Apodini requests and responses can be colletively represented as a JSON array, which is used as the body of an HTTP request or response. As HTTP Request Headers can only be sent once, query parameters have to be represented as part of the JSON body."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"SingleParameterHandler"},{"type":"text","text":" (see below) could be supplied with the following HTTP body:"}]},{"type":"codeListing","syntax":"json","code":["[","    {","        \"query\": {","            \"name\": \"Max\"","        }","    },","    {","        \"query\": {","            \"name\": \"Moritz\"","        }","    }","]"]},{"type":"codeListing","syntax":"swift","code":["struct SingleParameterHandler: Handler {","    @Parameter var name: String","    @Environment(\\.connection) var connection: Connection","","","    func handle() -> Response<String> {","        print(name)","","        if connection.state == .end {","            return .final(\"End\")","        } else { \/\/ connection.state == .open","            return .nothing \/\/ Send no reponse to the client as the connection is not yet terminated","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Thus, proper streaming is not supported via HTTP\/1.1, as all of the requests have to be known a priori and are sent as one block."}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"HTTP\/2 Length-prefixed Streaming"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Via HTTP\/2’s streams, dynamic streaming is supported. Individual messages are length-prefixed, and the same encoding is used to represent query parameters in JSON as for the array-based streaming. A client implementing this lightweight protocol is provided (see "},{"type":"codeVoice","code":"HTTP2StreamingClient"},{"type":"text","text":"). Equivalently to Apodini Handlers on the server, client-side handlers can be implemented using "},{"type":"codeVoice","code":"StreamingDelegate"},{"type":"text","text":"s."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"See the following example of a "},{"type":"codeVoice","code":"StreamingDelegate"},{"type":"text","text":" which can send requests to the "},{"type":"codeVoice","code":"BidirectionalStreamingGreeter"},{"type":"text","text":" handler."}]},{"type":"codeListing","syntax":"swift","code":["struct BidirectionalStreamingGreeter1: Handler {","    @Parameter(.http(.query)) var country: String?","    ","    @Apodini.Environment(\\.connection) var connection","    ","    func handle() -> Apodini.Response<String> {","        switch connection.state {","        case .open:","            return .send(\"Hello, \\(country ?? \"World\")!\")","        case .end, .close:","            return .end","        }","    }","    ","    var metadata: AnyHandlerMetadata {","        Pattern(.bidirectionalStream)","        Operation(.create)","    }","}","```swift",""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"struct CountryStruct: Codable {"},{"type":"text","text":" "},{"type":"text","text":"let country: String"},{"type":"text","text":" "},{"type":"text","text":"}"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"final class GreeterDelegate: StreamingDelegate {"},{"type":"text","text":" "},{"type":"text","text":"typealias SRequest = DATAFrameRequest"},{"type":"text","text":" "},{"type":"text","text":"typealias SResponse = String"},{"type":"text","text":" "},{"type":"text","text":"var streamingHandler: HTTPClientStreamingHandler"},{"type":"text","text":"?"},{"type":"text","text":" "},{"type":"text","text":"var headerFields: BasicHTTPHeaderFields"}]},{"type":"codeListing","syntax":null,"code":["let countries = [\"Germany\", \"USA\"]","var nextExpectedIndex = 0","","func handleInbound(response: String) {","    if !response.contains(countries[nextExpectedIndex]) {","        fatalError(\"Got the wrong country!\")","    }","    nextExpectedIndex += 1","}","","func handleStreamStart() {","    for country in countries {","        sendOutbound(request: DATAFrameRequest(CountryStruct(country: country)))","    }","    close()","}","","func handleClose() {","    precondition(nextExpectedIndex == 2)","}","","init(_ headerfields: BasicHTTPHeaderFields) {","    self.headerFields = headerfields","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"}"}]},{"type":"codeListing","syntax":null,"code":["","For further examples, see the `HTTP2BidirectionalTests`, `HTTP2ServiceSideTests`, and `HTTP2ClientSideTests`.","","## Topics","","The following sections detail how different communication patterns can be implemented using the tools described in the previous chapter.","","### Pattern Implementation","","- <doc:RequestResponse>","- <doc:ClientSideStream>","- <doc:ServiceSideStream>","- <doc:BidirectionalStream>"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/apodini\/patternimplementation"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Apodini\/documentation\/Apodini\/PatternImplementation","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Implemented communication patterns."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Pattern Implementation","role":"article","modules":[{"name":"Apodini"}]},"hierarchy":{"paths":[["doc:\/\/Apodini\/documentation\/Apodini","doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern"]]},"seeAlsoSections":[{"title":"Pattern Implementation","identifiers":["doc:\/\/Apodini\/documentation\/Apodini\/RequestResponse","doc:\/\/Apodini\/documentation\/Apodini\/ClientSideStream","doc:\/\/Apodini\/documentation\/Apodini\/ServiceSideStream","doc:\/\/Apodini\/documentation\/Apodini\/BidirectionalStream"],"generated":true}],"references":{"doc://Apodini/documentation/Apodini/ServiceSideStream":{"role":"article","title":"Service-Side Stream","abstract":[{"type":"text","text":"Provide a code example of service-side stream."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/ServiceSideStream","kind":"article","type":"topic","url":"\/documentation\/apodini\/servicesidestream"},"doc://Apodini/documentation/Apodini":{"role":"collection","title":"Apodini","abstract":[{"type":"text","text":"A declarative, composable framework to build web services using Swift."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini","kind":"symbol","type":"topic","url":"\/documentation\/apodini"},"doc://Apodini/documentation/Apodini/RequestResponse":{"role":"article","title":"Request-Response","abstract":[{"type":"text","text":"Usage of Request and Response pattern."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/RequestResponse","kind":"article","type":"topic","url":"\/documentation\/apodini\/requestresponse"},"doc://Apodini/documentation/Apodini/CommunicationPattern":{"role":"collectionGroup","title":"Communication Pattern","abstract":[{"type":"text","text":"Communication patterns and their usage in different client-service protocols."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern","kind":"article","type":"topic","url":"\/documentation\/apodini\/communicationpattern"},"doc://Apodini/documentation/Apodini/BidirectionalStream":{"role":"collectionGroup","title":"Bidirectional Stream","abstract":[{"type":"text","text":"Provide a code example of bidirectional streams."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/BidirectionalStream","kind":"article","type":"topic","url":"\/documentation\/apodini\/bidirectionalstream"},"doc://Apodini/documentation/Apodini/Component":{"role":"symbol","title":"Component","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Component"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Component"},{"type":"text","text":" is the central building block of  Apodini. Each component handles a specific functionality of the Apodini web service."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Component"}],"url":"\/documentation\/apodini\/component"},"doc://Apodini/documentation/Apodini/Handler":{"role":"symbol","title":"Handler","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Handler"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" is a "},{"type":"codeVoice","code":"Component"},{"type":"text","text":" which defines an endpoint and can handle requests."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Handler"}],"url":"\/documentation\/apodini\/handler"},"doc://Apodini/documentation/Apodini/ClientSideStream":{"role":"article","title":"Client-Side Stream","abstract":[{"type":"text","text":"Provide an implementation of a client-side stream."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/ClientSideStream","kind":"article","type":"topic","url":"\/documentation\/apodini\/clientsidestream"}}}