{"seeAlsoSections":[{"title":"Advanced","identifiers":["doc:\/\/Apodini\/documentation\/Apodini\/BuildingExporters","doc:\/\/Apodini\/documentation\/Apodini\/HandlerDelegation","doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern","doc:\/\/Apodini\/documentation\/Apodini\/ProtocolBuffers","doc:\/\/Apodini\/documentation\/Apodini\/RetrieveRelationship","doc:\/\/Apodini\/documentation\/Apodini\/DSLComponents","doc:\/\/Apodini\/documentation\/Apodini\/Semantic-Model","doc:\/\/Apodini\/documentation\/Apodini\/Inter-Component-Communication"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"configuration"},{"type":"text","text":" variable of the "},{"type":"codeVoice","code":"WebService"},{"type":"text","text":" allows developers to specify various settings of the Apodini web service. The probably most important one is the configuration of the Exporters, so what interfaces of the declaratively defined web service are exposed. Of course, the DSL of Apodini should also allow the developer to configure the exporters themselves, so for example what Encoding\/Decoding strategy should be used by the exporter."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This results in certain requirements that the ExporterConfiguration must fulfill. First, the exposed interfaces should be configurable via exporters as well as the exporters themselves. Furthermore, associated exporters, as for example the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter and the "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporter should be able to share their configuration without the need for the developer to pass the configuration twice."}]},{"anchor":"Exporter-specific-Configuration","level":3,"type":"heading","text":"Exporter-specific Configuration"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Apodini’s DSL implements these requirements in the following way. This example shows the definition of the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" interface exporter that exposes the "},{"type":"codeVoice","code":"WebService"},{"type":"text","text":" via a RESTful API."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniREST","","public struct Example: WebService {","    public var configuration: Configuration { ","        REST()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Furthermore, as stated by our requirements, exporters should be configurable. An example would be the custom specification of the Encoding strategy of the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter. By default, the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter uses a "},{"type":"codeVoice","code":"JSONEncoder"},{"type":"text","text":" with the "},{"type":"codeVoice","code":".prettyPrinted"},{"type":"text","text":" and "},{"type":"codeVoice","code":".withoutEscapingSlashes"},{"type":"text","text":" options and a "},{"type":"codeVoice","code":"JSONDecoder"},{"type":"text","text":" with only the standard options."}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Apodini","import ApodiniREST","","public struct Example: WebService {","    private var jsonEncoder: JSONEncoder {","        let encoder = JSONEncoder()","        encoder.outputFormatting = .prettyPrinted","        encoder.dateEncodingStrategy = .iso8601","        return encoder","    }","","    public var configuration: Configuration { ","        REST(encoder: jsonEncoder)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This can be done for all kinds of coding strategies, for example XML, but this requires the developer to write an extension for the respective coder which conforms to the "},{"type":"codeVoice","code":"AnyEncoder"},{"type":"text","text":" or "},{"type":"codeVoice","code":"AnyDecoder"},{"type":"text","text":" protocol of the "},{"type":"codeVoice","code":"ApodiniREST"},{"type":"text","text":" target. This protocol specifies a "},{"type":"codeVoice","code":"func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders)"},{"type":"text","text":" and a "},{"type":"codeVoice","code":"func decode<D>(_ type: D.Type, from data: Data) throws -> D where D: Decodable"},{"type":"text","text":" function that must be implemented by the user. This is required since the RESTful routes are handled by Vapor which requires such a function (via the "},{"type":"codeVoice","code":"ContentEncoder"},{"type":"text","text":" or "},{"type":"codeVoice","code":"ContentDecoder"},{"type":"text","text":" protocol). An example with XML Coders would be the following:"}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Apodini","import ApodiniREST","import SotoXML","","public struct Example: WebService {","    public var configuration: Configuration { ","        REST(encoder: XMLEncoder(), decoder: XMLDecoder())","    }","}","","extension XMLEncoder: AnyEncoder {","    public func encode<E>(_ encodable: E, to body: inout ByteBuffer, headers: inout HTTPHeaders) throws where E: Encodable {","        headers.contentType = .xml","        try body.writeBytes(self.encode(encodable))","    }","","    private func encode<E>(_ value: E) throws -> Data where E: Encodable {","        let element: XML.Element = try self.encode(value)","        return element.xmlString.data(using: .utf8)!","    }","}","","extension XMLDecoder: AnyDecoder {","    public func decode<D>(_ type: D.Type, from data: Data) throws -> D where D: Decodable {","        let xmlElement = try XML.Element(xmlData: data)","        return try self.decode(type, from: xmlElement)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This now encodes and decodes all messages coming from or to RESTful routes in the XML format. Of course, these coding configurations can be extended to an arbitrary coding format, the developer just needs to let the coder conform to the "},{"type":"codeVoice","code":"AnyEncoder"},{"type":"text","text":" or "},{"type":"codeVoice","code":"AnyDecoder"},{"type":"text","text":" protocol and therefore implement the respective coding functions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Furthermore, the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter provides a parameter to enable case-insensitive routing with the parameter "},{"type":"codeVoice","code":"caseInsensitiveRouting"},{"type":"text","text":". By default, this parameter is set to "},{"type":"codeVoice","code":"false"},{"type":"text","text":", conforming to the actual URL standards."}]},{"anchor":"Shared-Configurations-of-Associated-Exporters","level":3,"type":"heading","text":"Shared Configurations of Associated Exporters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A further requirement is the shared configuration of associated exporters. This might seems unintuitive at first, what exporters are actually dependent on each other, shouldn’t they be independently exporting some kind of interface? As an answer, I state the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" and "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporters. The "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter is completely independent and doesn’t need the "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporter at all. However, in the other way around this doesn’t hold up. The "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporter generates a description of a webservice and this webservice is required to be RESTful. Therefore, the "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporter has a dependence on the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter and can only “exist” when the parent "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter is present."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here an example of these associated, or nested, exporters:"}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniREST","import ApodiniOpenAPI","","public struct Example: WebService {","    public var configuration: Configuration { ","        REST {","            OpenAPI()","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This “nested” expression in the DSL of Apodini makes the specification of exporters very intuitive and doesn’t allow for any errors, for example an "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporter but no associated "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter. The “nesting” of associated exporters is implemented via Swift’s "},{"type":"codeVoice","code":"ResultBuilder"},{"type":"text","text":"s, so it also allows for multiple associated exporters (will maybe get relevant in the future)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Furthermore, this syntax allows for the configuration of both exporters. The configuration of the “parent” exporter, so the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter, is passed onto the “nested” "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporter, so it for example can use the coding configuration of the "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter."}]},{"type":"codeListing","syntax":"swift","code":["import Foundation","import Apodini","import ApodiniREST","import ApodiniOpenAPI","","public struct Example: WebService {","    public var configuration: Configuration { ","        REST(encoder: JSONEncoder(), decoder: JSONDecoder()) {","            OpenAPI(outputFormat: .yaml,","                    outputEndpoint: \"\/oas\",","                    swaggerUiEndpoint: \"\/oas-ui\")","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another feature of this DSL is the prevention of wrongly passed associated exporters. For example, an associated "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporter is only allowed if the coding format is JSON. So this is allowed (since the default coders are JSON)"}]},{"type":"codeListing","syntax":"swift","code":["REST {","    OpenAPI()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"but this isn’t"}]},{"type":"codeListing","syntax":"swift","code":["REST(encoder: XMLEncoder()) {","    OpenAPI()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This concept also extends to other associated exporters, so for example a "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" exporter isn’t allowed to have an associated "},{"type":"codeVoice","code":"Protobuffer"},{"type":"text","text":" exporter or a "},{"type":"codeVoice","code":"WebSocket"},{"type":"text","text":" exporter isn’t allowed to have any associated exporters (at the moment). With that, Apodini’s DSL prevents small accidental mistakes by the developer that are even enforced at compile-time (since Swift is a statically typed language)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some other types of exporters (and associated exporters) can be seen in the following examples, the concept stays the same:"}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniGRPC","import ApodiniProtobuffer","","public struct Example: WebService {","    public var configuration: Configuration { ","        GRPC(integerWidth: .thirtyTwo) {","            Protobuffer()","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here the "},{"type":"codeVoice","code":"Protobuffer"},{"type":"text","text":" exporter also can’t exist without the "},{"type":"codeVoice","code":"GRPC"},{"type":"text","text":" exporter, similar to "},{"type":"codeVoice","code":"REST"},{"type":"text","text":" and "},{"type":"codeVoice","code":"OpenAPI"},{"type":"text","text":" exporters."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniWebSocket","","public struct Example: WebService {","    public var configuration: Configuration { ","        WebSocket(path: \"apodini\/ws\")","    }","}"]},{"anchor":"Auditing-your-REST-or-HTTP-API","level":3,"type":"heading","text":"Auditing your REST or HTTP API"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Many best practices have been developed in the last decades which constrain REST and HTTP APIs. To ensure compliance with these, you can use the "},{"type":"codeVoice","code":"APIAuditor"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniREST","import ApodiniAudit","","public struct Example: WebService {","    public var configuration: Configuration { ","        REST {","            APIAuditor()","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more information on how to run an audit and configure the auditor, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Auditing"}]}]}],"variants":[{"paths":["\/documentation\/apodini\/exporterconfiguration"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Apodini\/documentation\/Apodini\/ExporterConfiguration","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Extensive configuration options for Apodini Exporters."}],"kind":"article","metadata":{"modules":[{"name":"Apodini"}],"role":"collectionGroup","title":"Configuration of Exporters"},"hierarchy":{"paths":[["doc:\/\/Apodini\/documentation\/Apodini"],["doc:\/\/Apodini\/documentation\/Apodini","doc:\/\/Apodini\/documentation\/Apodini\/BuildingExporters"],["doc:\/\/Apodini\/documentation\/Apodini","doc:\/\/Apodini\/documentation\/Apodini\/Metadata","doc:\/\/Apodini\/documentation\/Apodini\/MetadataProviderGuide","doc:\/\/Apodini\/documentation\/Apodini\/BuildingExporters"]]},"topicSections":[{"title":"Protocols","identifiers":["doc:\/\/Apodini\/documentation\/Apodini\/WebService","doc:\/\/Apodini\/documentation\/Apodini\/Configuration"]}],"references":{"doc://Apodini/documentation/Apodini/Inter-Component-Communication":{"role":"article","title":"Inter-Component Communication","abstract":[{"type":"text","text":"Web services deployed with Apodini Deployer can be distributed across different nodes. Inter-component communication enables the communication between components between these nodes."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Inter-Component-Communication","kind":"article","type":"topic","url":"\/documentation\/apodini\/inter-component-communication"},"doc://Apodini/documentation/Apodini/RetrieveRelationship":{"role":"collectionGroup","title":"Retrieving Relationship Information","abstract":[{"type":"text","text":"This proposal describes how relationship information can be generated from the DSL, introduces some concepts"},{"type":"text","text":" "},{"type":"text","text":"to give hints for relationship retrieval and adds mechanisms to manually define hints."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/RetrieveRelationship","kind":"article","type":"topic","url":"\/documentation\/apodini\/retrieverelationship"},"doc://Apodini/documentation/Apodini/ProtocolBuffers":{"role":"collectionGroup","title":"Protocol Buffers","abstract":[{"type":"text","text":"Describe how to export the webservice via IDL exporter."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/ProtocolBuffers","kind":"article","type":"topic","url":"\/documentation\/apodini\/protocolbuffers"},"doc://Apodini/documentation/Apodini/MetadataProviderGuide":{"role":"collectionGroup","title":"Metadata Provider Guide","abstract":[{"type":"text","text":"A guide on how to use the Metadata system from the perspective of a Metadata Provider."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/MetadataProviderGuide","kind":"article","type":"topic","url":"\/documentation\/apodini\/metadataproviderguide"},"doc://Apodini/documentation/Apodini/DSLComponents":{"role":"collectionGroup","title":"DSL Components","abstract":[{"type":"text","text":"Apodini DSL central building blocks."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/DSLComponents","kind":"article","type":"topic","url":"\/documentation\/apodini\/dslcomponents"},"doc://Apodini/documentation/Apodini/WebService":{"role":"symbol","title":"WebService","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"WebService"}],"abstract":[{"type":"text","text":"Each Apodini program consists of a "},{"type":"codeVoice","code":"WebService"},{"type":"text","text":"component that is used to describe the Web API of the Web Service"}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WebService"}],"url":"\/documentation\/apodini\/webservice"},"doc://Apodini/documentation/Apodini/InterfaceExporter":{"role":"symbol","title":"InterfaceExporter","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"InterfaceExporter"}],"abstract":[{"type":"text","text":"An "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter"},{"type":"text","text":" is a type which requires access to the web service’s structure and"},{"type":"text","text":" "},{"type":"text","text":"internals."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"InterfaceExporter"}],"url":"\/documentation\/apodini\/interfaceexporter"},"doc://Apodini/documentation/Apodini/CommunicationPattern":{"role":"collectionGroup","title":"Communication Pattern","abstract":[{"type":"text","text":"Communication patterns and their usage in different client-service protocols."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/CommunicationPattern","kind":"article","type":"topic","url":"\/documentation\/apodini\/communicationpattern"},"doc://Apodini/documentation/Apodini/HandlerDelegation":{"role":"collectionGroup","title":"Delegating Handlers","abstract":[{"type":"text","text":"Defining reusable and assertive "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":"s."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/HandlerDelegation","kind":"article","type":"topic","url":"\/documentation\/apodini\/handlerdelegation"},"doc://Apodini/documentation/Apodini/BuildingExporters":{"role":"collectionGroup","title":"Building Exporters","abstract":[{"type":"text","text":"Writing a web service with Apodini is easy - as long as there are "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter"},{"type":"text","text":"s suitable for your purposes. If that is not the case, you might need to adapt one, or build a new one."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/BuildingExporters","kind":"article","type":"topic","url":"\/documentation\/apodini\/buildingexporters"},"doc://Apodini/documentation/Apodini":{"role":"collection","title":"Apodini","abstract":[{"type":"text","text":"A declarative, composable framework to build web services using Swift."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini","kind":"symbol","type":"topic","url":"\/documentation\/apodini"},"doc://Apodini/documentation/Apodini/Auditing":{"role":"article","title":"Auditing","abstract":[{"type":"text","text":"Audit your REST or HTTP web service for best practice compliance."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Auditing","kind":"article","type":"topic","url":"\/documentation\/apodini\/auditing"},"doc://Apodini/documentation/Apodini/Semantic-Model":{"role":"collectionGroup","title":"Semantic Model","abstract":[{"type":"text","text":"The semantic model is an intermediary model that is somewhere in the middle between the web service declaration you write using the Apodini DSL and the behavior of the web service."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Semantic-Model","kind":"article","type":"topic","url":"\/documentation\/apodini\/semantic-model"},"doc://Apodini/documentation/Apodini/Configuration":{"role":"symbol","title":"Configuration","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Configuration"}],"abstract":[{"type":"codeVoice","code":"Configuration"},{"type":"text","text":"s are used to register services to Apodini."},{"type":"text","text":" "},{"type":"text","text":"Each "},{"type":"codeVoice","code":"Configuration"},{"type":"text","text":" handles different kinds of services."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Configuration","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Configuration"}],"url":"\/documentation\/apodini\/configuration"},"doc://Apodini/documentation/Apodini/Metadata":{"role":"collectionGroup","title":"Metadata","abstract":[{"type":"text","text":"Map requirements of your web service into the implementation."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Metadata","kind":"article","type":"topic","url":"\/documentation\/apodini\/metadata"}}}