{"seeAlsoSections":[{"title":"Ecosystem","identifiers":["doc:\/\/Apodini\/documentation\/Apodini\/DatabaseConnection","doc:\/\/Apodini\/documentation\/Apodini\/Authorization","doc:\/\/Apodini\/documentation\/Apodini\/PushNotifications","doc:\/\/Apodini\/documentation\/Apodini\/Jobs","doc:\/\/Apodini\/documentation\/Apodini\/OpenAPI"],"generated":true}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to make in instrumentation of the web service as easy as possible for developers, Apodini provides the "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" package. The goal of the library is to simplify the observability process within the declarative Apodini framework, remove hurdles for developers to instrument the entire web service extensivly, and allows them to easily state observability features in the DSL of Apodini. Developers have to write as little code as possible in order to achieve observability by using ApodiniObserve’s convenience features. Furthermore, the package is able to automate the observing process completely by collecting default information about the execution of the web service with only a few lines of code written by the developer."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" heavily relies on Apple’s observability libraries, especially "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-log"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-metrics"},{"type":"text","text":", and "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing"},{"type":"text","text":", to provide instrumentation possibilities to developers. It’s important to note that these packages just define an observability API (“observability frontend”), but don’t actually process and transmit the instrumented telemetry information to an observability software stack. This functionality is left to individual observability integrations (“observability backends”) that conform to the processing APIs of Apple’s observability libraries. A list of compatible observability integrations can be found on the "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-log"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-log","overridingTitle":"GitHub page of swift-log"},{"type":"text","text":", the "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-metrics"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-metrics","overridingTitle":"GitHub page of swift-metrics"},{"type":"text","text":", as well as the "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-distributed-tracing"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing","overridingTitle":"GitHub page of swift-distributed-tracing"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"All in all, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" provides functionality to easily collect information about the system’s execution in the form of logs, metrics, and tracing. Logs and metrics are automatically enrichted by adding context information to them in order to extract actionable insights from the information. Furthermore, as mentioned before, the entire observability process can be automated by "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" to a certain extent by collecting configurable default observability types, so that developers don’t have to manually instrument the different web routes themselves. Trace collection is currently not automated yet."}]},{"anchor":"Logs","level":2,"type":"heading","text":"Logs"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first building block of observing a software system are Logs. An event log, or often commonly called a log, is a sequence of immutable textual records generated in response to a discrete event consisting of a timestamp, a log level, a context, and a payload. Logs are often used by developers to debug rarely occurring events. They enable instrumenting the code in-depth by providing lots of context and detailed information about the arisen event. As such, logs provide valuable insights for detecting unpredictable system behaviors and make lots of context information available to the developer which allows them to pinpoint the underlying fault more quickly."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Therefore, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" provides an "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" that drastically simplifies the logging process in an Apodini web service."},{"type":"text","text":" "},{"type":"text","text":"As explained above, it is important to note that the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" just defines the API of the logger, the actual processing and transmission to different obserevability software stacks like "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.elastic.co\/elastic-stack\/"},{"type":"text","text":" is done by so called “obervability backends”, in the case of a logger a "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":". These "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s are compatible with the API for “obervability backends” defined by the "},{"overridingTitleInlineContent":[{"type":"text","text":"swift-log"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-log","overridingTitle":"swift-log"},{"type":"text","text":" package. This enables developers to easily write their own "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" and publish them open-source. A list of compatible "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s can be found on "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-log"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-log","overridingTitle":"GitHub page of swift-log"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As a standalone package, the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" is only able to direct its logs to the most basic "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":", which simply prints the logs to stdout. To direct logs to more advanced observability software stacks like the "},{"overridingTitleInlineContent":[{"type":"text","text":"Elastic stack"}],"isActive":true,"type":"reference","identifier":"https:\/\/www.elastic.co\/elastic-stack\/","overridingTitle":"Elastic stack"},{"type":"text","text":", developers can use already existing open-source "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s. In the case of the "},{"overridingTitleInlineContent":[{"type":"text","text":"Elastic stack"}],"isActive":true,"type":"reference","identifier":"https:\/\/www.elastic.co\/elastic-stack\/","overridingTitle":"Elastic stack"},{"type":"text","text":", this would be a "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" that sends the logs to "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.elastic.co\/logstash\/"},{"type":"text","text":" which then ingests the data to "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.elastic.co\/elasticsearch"},{"type":"text","text":" which can then be visualized by "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.elastic.co\/kibana\/"},{"type":"text","text":". After taking a look at the available "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s on the "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-log"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-log","overridingTitle":"GitHub page of swift-log"},{"type":"text","text":", in our example the developer decides to utilize the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/Apodini\/swift-log-elk"},{"type":"text","text":" "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" as the “obervability backend” for the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":". Note that the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" works with all "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s, not only the mentioned Logstash "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"."}]},{"anchor":"Add-Target-Dependency","level":3,"type":"heading","text":"Add Target Dependency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to use the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" in combination with an appropriate "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":", the developer first has to state the dependency "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" in the target as well as the dependency to the respective "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" package, in the case of the Logstash example the "},{"overridingTitleInlineContent":[{"type":"text","text":"swift-log-elk"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/Apodini\/swift-log-elk","overridingTitle":"swift-log-elk"},{"type":"text","text":" package."}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","    .package(url: \"https:\/\/github.com\/Apodini\/Apodini.git\", from: \"0.5.0\"),","    .package(url: \"https:\/\/github.com\/Apodini\/swift-log-elk.git\", from: \"0.2.0\")","],","targets: [","    .executableTarget(","        name: \"WebService\",","        dependencies: [","            .product(name: \"Apodini\", package: \"Apodini\"),","            .product(name: \"ApodiniObserve\", package: \"Apodini\"),","            .product(name: \"LoggingELK\", package: \"swift-log-elk\")","        ]","    ),","]‚"]},{"anchor":"ApodiniLogger-Configuration","level":3,"type":"heading","text":"ApodiniLogger Configuration"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After stating the dependencies to the respective packages, the developer first has to configure the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" with the to-be-used "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s."},{"type":"text","text":" "},{"type":"text","text":"Add the "},{"type":"codeVoice","code":"LoggerConfiguration"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"configuration"},{"type":"text","text":" property of the "},{"type":"codeVoice","code":"WebService"},{"type":"text","text":" and specify the to be used "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s (in this example only the "},{"type":"codeVoice","code":"LogstashLogHandler"},{"type":"text","text":"), the global logLevel as well as a developer-defined configuration closure, that sets up the to be used "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s (for example the network address of the "},{"type":"codeVoice","code":"Logstash"},{"type":"text","text":" component). In order to set up multiple "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s, just pass multiple "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s in the initializor."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import LoggingELK","","struct ExampleWebService: WebService {","    var content: some Component {","        \/\/ ...","    }","    ","    var configuration: Configuration {","        \/\/ ...","","        \/\/ Setup of ApodiniLogger with a LogstashLogHandler backend","        LoggerConfiguration(logHandlers: LogstashLogHandler.init,","                            logLevel: .info) {","            LogstashLogHandler.setup(","                hostname: \"0.0.0.0\",","                port: 31311","                \/\/ further configurations possible","            )","        }","    }","}"]},{"anchor":"Instrument","level":3,"type":"heading","text":"Instrument"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After configuring the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":", it is ready to be used in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":" and the different "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"’s it offers."},{"type":"text","text":" "},{"type":"text","text":"In the example below, a new "},{"type":"codeVoice","code":"SensorType"},{"type":"text","text":" is created in a database. In order to get insights into the execution of this "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" at runtime, it is instrumented via logging statements with the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":". The logger that is stated as a property in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" has to be annotated with the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" property wrapper. This property wrapper instanciates and configures the logger correctly (automatically assigns an appropriate label etc.), so that the developer can directly start using it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" offers a range of functions corresponding to the different logLevels, like "},{"type":"codeVoice","code":".info()"},{"type":"text","text":", "},{"type":"codeVoice","code":".error()"},{"type":"text","text":", or "},{"type":"codeVoice","code":".critical()"},{"type":"text","text":". Depending on the currently configured logLevel, these messages are either filtered out (as their relevance isn’t high enough) or further processed. Furthermore, each logging statement can be passed an extra metadata struct that contains application-specific data that may be relevant to site reliability engineers."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import Shared","","struct CreateSensorType: Handler {","    @Environment(\\.databaseModel)","    var databaseModel: DatabaseModel","    ","    @Parameter(.http(.body))","    var sensorTypeContent: SensorType","    ","    @Throws(.serverError, reason: \"Sensor type couldn't be saved correctly\")","    var serverError: ApodiniError","    ","    @ApodiniLogger","    var logger","","    func handle() async throws -> SensorType {","        guard let sensorType = try? await databaseModel.createSensorType(sensorTypeContent) else {","            logger.error(\"Couldn't create new sensor type with ID \\(sensorTypeContent.id)\", metadata: [\"sensorTypeID\": .string(sensorTypeContent.id?.description)])","            throw serverError","        }","        ","        logger.info(\"New sensor type with ID \\(sensorTypeContent.id) created\")","        ","        return sensorType","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Further configuration possibilities of the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" are a custom ID, custom label and logLevel, that overwrites the globally configured logLevel of the "},{"type":"codeVoice","code":"LoggerConfiguration"},{"type":"text","text":". Furthermore, the level of automatically collected metadata can be configured ("},{"type":"codeVoice","code":".all"},{"type":"text","text":", "},{"type":"codeVoice","code":".reduced"},{"type":"text","text":", "},{"type":"codeVoice","code":".none"},{"type":"text","text":", "},{"type":"codeVoice","code":".custom(metadata: [String])"},{"type":"text","text":", for further information take a look at the section below) as well as a custom "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":" the overwrites the globally configured "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","","struct CreateSensorType: Handler {","    @ApodiniLogger(id: UUID(),","                   label: \"org.apodini.logger.test\",","                   logLevel: .info,","                   metadataLevel: .reduced,","                   logHandler: LogstashLogHandler.init)","    var logger","}"]},{"anchor":"Automatic-context-aggregation","level":3,"type":"heading","text":"Automatic context aggregation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A unique functionality of the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" is the ability to automatically attach context information to the log messages to enrich the logged information. Context information is very important in the logging process in order to comprehend the system’s execution in retrospect and beeing able to quickly localize the underlying fault. Therefore, the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" automatically attaches data about the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Connection"},{"type":"text","text":", the used "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter"},{"type":"text","text":", and the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Endpoint"},{"type":"text","text":" to the log messages as well as the Apodini "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Information"},{"type":"text","text":" data struct which, for example in the case of the REST exporter, contains HTTP header values. Furthermore, data about the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Request"},{"type":"text","text":" itself like parameters or content type are automatically attached to log messages."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The context information is inserted as "},{"type":"codeVoice","code":"Logger.Metadata"},{"type":"text","text":" to the log messages which will then be further processed by the "},{"type":"codeVoice","code":"LogHandler"},{"type":"text","text":"’s to enrich the logging messages."},{"type":"text","text":" "},{"type":"text","text":"The structure of the context information is as follows:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"connection"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"remoteAddress"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"eventLoop"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"request"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"description"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"parameters"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Further data dependent on the exporter"}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"information"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Data ependent on the exporter, like HTTP Headers for REST"}]}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"endpoint"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"name"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"endpointParameters"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"operation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"endpointPath"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"version"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"handlerReturnType"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"communicationPattern"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"exporter"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"type"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"parameterNamespace"}]}]}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This functionality can also be configured by the user via the initializer of the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":" (see above). Depending on the comprehensiveness of the context information, developers can state the "},{"type":"codeVoice","code":".all"},{"type":"text","text":", "},{"type":"codeVoice","code":".reduced"},{"type":"text","text":", "},{"type":"codeVoice","code":".none"},{"type":"text","text":", and "},{"type":"codeVoice","code":".custom(metadata: [String])"},{"type":"text","text":" metadata levels, which scale down the size of the collected information and therefore result in speed improvements. Even a custom configuration is possible, in which the developer can pass the first-level keys of the context information that is desired. Possible first-level keys are:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"connection"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"request"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"information"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"endpoint"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"exporter"}]}]}]},{"anchor":"Metrics","level":2,"type":"heading","text":"Metrics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another building block of observing software systems are Metrics. A metric is a numeric representation of data measured over a certain time interval. Since metrics can be broken down into simple numbers, they can be aggregated and performed mathematical operations and modeling upon. These models can even be stretched out in order to predict future system behavior from data collected in the past. These properties make metrics well suited to visually present captured information in a dashboard that reflects historical trends."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to easily instrument an Apodini web service with Metrics, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" provides "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types, namely an "},{"type":"codeVoice","code":"ApodiniCounter"},{"type":"text","text":", "},{"type":"codeVoice","code":"ApodiniGauge"},{"type":"text","text":", "},{"type":"codeVoice","code":"ApodiniHistogram"},{"type":"text","text":", "},{"type":"codeVoice","code":"ApodiniRecorder"},{"type":"text","text":", and an "},{"type":"codeVoice","code":"ApodiniTimer"},{"type":"text","text":". A Counter is a cumulative, monotonically increasing metric, allowing only to increase the wrapped value or to reset it to zero, and is typically used to measure the number of incoming requests or occurred errors. A Gauge on the other hand wraps a numeric value that can arbitrarily go up or down and is therefore mostly used to record CPU utilization or memory usage. A Recorder observes values over a certain time frame and allows to perform aggregations on the collected information. A Timer is a more specialized form of a Recorder, focused on observing time values like the response time of a request."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similar to the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":", the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types are based upon the Apple observability library "},{"overridingTitleInlineContent":[{"type":"text","text":"swift-metrics"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-metrics","overridingTitle":"swift-metrics"},{"type":"text","text":". As mentioned before, these library just defines an API (“observability frontend”) which the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types reuse, the actual processing of the metrics data is done via "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s (“observability backends”), namely the "},{"type":"codeVoice","code":"CounterHandler"},{"type":"text","text":", "},{"type":"codeVoice","code":"RecorderHandler"},{"type":"text","text":", and "},{"type":"codeVoice","code":"TimerHandler"},{"type":"text","text":". Developers are free to implement and publish these "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s on their own as they are defined as a protocol in the "},{"overridingTitleInlineContent":[{"type":"text","text":"swift-metrics"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-metrics","overridingTitle":"swift-metrics"},{"type":"text","text":" library. A list of already available, open-source "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s can be found on the "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-metrics"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-metrics","overridingTitle":"GitHub page of swift-metrics"},{"type":"text","text":". These "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s process and transfer the metrics data to a respective observability software stack. One of the most popular tools for metrics is "},{"type":"reference","isActive":true,"identifier":"https:\/\/prometheus.io\/"},{"type":"text","text":". A fitting "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":" is the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/MrLotU\/SwiftPrometheus"},{"type":"text","text":" package, which this article will use as an example. Note that the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types work with all "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s, not only the mentioned Prometheus "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"."}]},{"anchor":"Add-Target-Dependency","level":3,"type":"heading","text":"Add Target Dependency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to use the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types in combination with an appropriate "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":", the developer first has to state the dependency "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" in the target as well as the dependency to the respective "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":" package, in the case of the Prometheus example the "},{"overridingTitleInlineContent":[{"type":"text","text":"SwiftPrometheus"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/MrLotU\/SwiftPrometheus","overridingTitle":"SwiftPrometheus"},{"type":"text","text":" package."}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","    .package(url: \"https:\/\/github.com\/Apodini\/Apodini.git\", from: \"0.5.0\"),","    .package(url: \"https:\/\/github.com\/MrLotU\/SwiftPrometheus.git\", from: \"1.0.0-alpha\")","],","targets: [","    .executableTarget(","        name: \"WebService\",","        dependencies: [","            .product(name: \"Apodini\", package: \"Apodini\"),","            .product(name: \"ApodiniObserve\", package: \"Apodini\"),","            .product(name: \"SwiftPrometheus\", package: \"SwiftPrometheus\")","        ]","    ),","]‚"]},{"anchor":"ApodiniMetrics-Configuration","level":3,"type":"heading","text":"ApodiniMetrics Configuration"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After stating the dependencies to the respective packages, the developer first has to configure the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types with the to-be-used "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s."},{"type":"text","text":" "},{"type":"text","text":"Add the "},{"type":"codeVoice","code":"MetricsConfiguration"},{"type":"text","text":" to the "},{"type":"codeVoice","code":"configuration"},{"type":"text","text":" property of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":" and specify the to be used "},{"type":"codeVoice","code":"MetricsFactory"},{"type":"text","text":"’s (in this example only the "},{"type":"codeVoice","code":"PrometheusMetricsFactory"},{"type":"text","text":") as well as a configuration for automatically collecting system metrics, so CPU utilization, free memory, or open file descriptors."},{"type":"text","text":" "},{"type":"text","text":"In comparison to the "},{"type":"codeVoice","code":"LoggerConfiguration"},{"type":"text","text":", the "},{"type":"codeVoice","code":"MetricsConfiguration"},{"type":"text","text":" is more complex as there are different types of metrics software stacks available:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The most typical kind, a pull-based metrics software, for example Prometheus, pulls the metrics data from a specific system in a certain time interval. This results in the need for the software system to provide an endpoint (most typically a “\/metrics” endpoint) where the metrics data can be fetched from by Prometheus. In "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" this behaviour corresponds to the "},{"type":"codeVoice","code":"MetricPullHandlerConfiguration"},{"type":"text","text":". This configuration type takes a factory, so the to-be-used "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s, an endpoint where the metrics data should be exposed, as well as a custom collection closure that returns the temporarily stored metrics data that should then be served by the metrics endpoint."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"On the other hand, a push-based metrics software pushes the metrics data directly to a metrics software, therefore the configuration with "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" is more simple. n "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" this behaviour corresponds to the "},{"type":"codeVoice","code":"MetricPushHandlerConfiguration"},{"type":"text","text":". This configuration only takes a factory of the to-be-used "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s, as the transmission logic is already implemented by the "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":" themselves."},{"type":"text","text":" "},{"type":"text","text":"In order to set up multiple "},{"type":"codeVoice","code":"MetricHandler"},{"type":"text","text":"’s, just pass multiple "},{"type":"codeVoice","code":"MetricPullHandlerConfiguration"},{"type":"text","text":" or "},{"type":"codeVoice","code":"MetricPushHandlerConfiguration"},{"type":"text","text":"’s in the initializor."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Furthermore, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" offers the automatic collection of system metrics, as described above. The developer is able to configure if data should be collected at all ("},{"type":"codeVoice","code":".on(configuration: SystemMetrics.Configuration)"},{"type":"text","text":", "},{"type":"codeVoice","code":".off"},{"type":"text","text":") and what types should be collected in what interval. It also offers a "},{"type":"codeVoice","code":".default"},{"type":"text","text":" option, which automatically collects all available system metrics every second. Currently, the ability to collect system metrics is limited to Linux-based systems."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import Metrics","import Prometheus","","struct ExampleWebService: WebService {","    var content: some Component {","        \/\/ ...","    }","    ","    var configuration: Configuration {","        \/\/ ...","","        \/\/ Setup of ApodiniMetrics with a PrometheusMetricsHandler backend","        MetricsConfiguration(","            handlerConfiguration: MetricPullHandlerConfiguration(","                factory: PrometheusMetricsFactory(","                    client: PrometheusClient(),","                    configuration: PrometheusMetricsFactory.Configuration()","                ),","                endpoint: \"\/metrics\",","                collect: { promise in","                    DispatchQueue.global().async {","                        do {","                            try MetricsSystem.prometheus().collect(into: promise)","                        } catch {","                            promise.fail(error)","                        }","                    }","    ","                    return promise.futureResult","                }","            ),","            systemMetricsConfiguration: ","                .on(","                    configuration: .init(","                        pollInterval: .seconds(3),","                        dataProvider: nil,","                        labels: .init(","                            prefix: \"process_\",","                            virtualMemoryBytes: \"virtual_memory_bytes\",","                            residentMemoryBytes: \"resident_memory_bytes\",","                            startTimeSeconds: \"start_time_seconds\",","                            cpuSecondsTotal: \"cpu_seconds_total\",","                            maxFds: \"max_fds\",","                            openFds: \"open_fds\"","                        )","                    )","                )","        )","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As the "},{"type":"codeVoice","code":"MetricsConfiguration"},{"type":"text","text":" is quite complex, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" offers a seperate "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/Apodini\/ApodiniObservePrometheus"},{"type":"text","text":" that drastically simplifies the configuration process for the common "},{"overridingTitleInlineContent":[{"type":"text","text":"Prometheus"}],"isActive":true,"type":"reference","identifier":"https:\/\/prometheus.io\/","overridingTitle":"Prometheus"},{"type":"text","text":" software stack. All available versions are listed in the GitHub releases. Include the dependency like:"}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","    .package(url: \"https:\/\/github.com\/Apodini\/ApodiniObservePrometheus.git\", from: \"<version>\"),","],","targets: [","    .executableTarget(","        name: \"WebService\",","        dependencies: [","            .product(name: \"Apodini\", package: \"Apodini\"),","            .product(name: \"ApodiniObserve\", package: \"Apodini\"),","            .product(name: \"ApodiniObservePrometheus\", package: \"ApodiniObservePrometheus\"),","        ]","    ),","]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This then enables a way simpler configuration like:"}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import ApodiniObservePrometheus","","struct ExampleWebService: WebService {","    var content: some Component {","        \/\/ ...","    }","    ","    var configuration: Configuration {","        \/\/ ...","","        \/\/ Setup of ApodiniMetrics with a PrometheusMetricsHandler backend","        MetricsConfiguration(","            handlerConfiguration: MetricPullHandlerConfiguration.defaultPrometheus,","            systemMetricsConfiguration: .default","        )","    }","}"]},{"anchor":"Instrument","level":3,"type":"heading","text":"Instrument"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After configuring the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types, they are ready to be used in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":" and the different "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"‘s it offers."},{"type":"text","text":" "},{"type":"text","text":"Similar to the example with the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":", in the example below, a new "},{"type":"codeVoice","code":"SensorType"},{"type":"text","text":" is created in a database. In order to get insights into the execution of this "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" at runtime, it is instrumented via the "},{"type":"codeVoice","code":"ApodiniCounter"},{"type":"text","text":". The counter that is stated as a property in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" has to be annotated with the "},{"type":"codeVoice","code":"ApodiniCounter"},{"type":"text","text":" property wrapper. This property wrapper instanciates and configures the counter correctly, so that the developer can directly start using it. The property wrappers has to be passed a label by the developer, as automatically assign labels don’t make sense for "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types (in contrast to the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Depending on the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types, the metric offers different functionalities. In our case, the "},{"type":"codeVoice","code":"ApodiniCounter"},{"type":"text","text":" offers a simple "},{"type":"codeVoice","code":".increment()"},{"type":"text","text":" function to increase the amount of the "},{"type":"codeVoice","code":"ApodiniCounter"},{"type":"text","text":" by a specific amount (default is 1). An overview of what functionalities are offered by what "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" type can be found on the "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-metrics"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-metrics","overridingTitle":"GitHub page of swift-metrics"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Furthermore, every "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" type is automatically enriched by context information, similar to the "},{"type":"codeVoice","code":"ApodiniLogger"},{"type":"text","text":". However, as most metrics software stacks efficiently store the metrics data in a time series database, it is important to only include the most relevant context information as otherwise the metrics data storage size blows up. The attached context information includes:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"endpoint"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"endpoint_path"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"exporter"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"operation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"communication_pattern"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"service_type"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"response_type"}]}]}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import Shared","","struct CreateSensorType: Handler {","    @Environment(\\.databaseModel)","    var databaseModel: DatabaseModel","    ","    @Parameter(.http(.body))","    var sensorTypeContent: SensorType","    ","    @Throws(.serverError, reason: \"Sensor type couldn't be saved correctly\")","    var serverError: ApodiniError","    ","    @ApodiniCounter(label: \"sensortype_created_counter\")","    var sensorTypeCreatedCounter","","    @ApodiniCounter(label: \"sensortype_failed_counter\")","    var sensorTypeFailedCounter","","    func handle() async throws -> SensorType {","        guard let sensorType = try? await databaseModel.createSensorType(sensorTypeContent) else {","            sensorTypeFailedCounter.increment()","            throw serverError","        }","        ","        sensorTypeCreatedCounter.increment()","        ","        return sensorType","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A further configuration possibility of the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" types is to manually pass labels to the initializer of the "},{"type":"codeVoice","code":"ApodiniMetric"},{"type":"text","text":" property wrapper. These labels will be merged with the automatically attached context information."}]},{"anchor":"Tracing","level":2,"type":"heading","text":"Tracing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The third building block of observability is Tracing."}]},{"anchor":"Add-Target-Dependency","level":3,"type":"heading","text":"Add Target Dependency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to use Apodini’s tracing capabilities in combination with an appropriate "},{"type":"codeVoice","code":"Instrument"},{"type":"text","text":", the developer first has to state the dependency "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" in the traget as well as the dependency to the respective "},{"type":"codeVoice","code":"Instrument"},{"type":"text","text":" or "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tracing backend"}]},{"type":"text","text":" package, in case of OpenTelemetry the "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/slashmo\/opentelemetry-swift"},{"type":"text","text":" package."}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","    .package(url: \"https:\/\/github.com\/Apodini\/Apodini.git\", from: \"<version>\"),","    .package(url: \"https:\/\/github.com\/slashmo\/opentelemetry-swift.git\", from: \"0.2.0\")","],","targets: [","    .executableTarget(","        name: \"WebService\",","        dependencies: [","            .product(name: \"Apodini\", package: \"Apodini\"),","            .product(name: \"ApodiniObserve\", package: \"Apodini\"),","            .product(name: \"OpenTelemetry\", package: \"opentelemetry-swift\"),","            .product(name: \"OtlpGRPCSpanExporting\", package: \"opentelemetry-swift\")","        ]","    )","]"]},{"anchor":"ApodiniTracing-Configuration","level":3,"type":"heading","text":"ApodiniTracing Configuration"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After stating the dependencies to the respective packages, the developer has to configure the tracing system with the to-be-used "},{"type":"codeVoice","code":"Instrument"},{"type":"text","text":"’s."},{"type":"text","text":" "},{"type":"text","text":"Add the"}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import OpenTelemetry","import OtlpGRPCSpanExporting","","struct ExampleWebService: WebService {","    var content: some Component {","        \/\/ ...","    }","","    var configuration: Configuration {","        \/\/ ...","","        TracingConfiguration(","            \/\/ Setup of tracing in Apodini with a OpenTelemetry backend","            InstrumentConfiguration { group in","                let otel = OTel(","                    serviceName: \"ExampleWebService\",","                    eventLoopGroup: group,","                    resourceDetection: .automatic(additionalDetectors: []),","                    idGenerator: OTel.RandomIDGenerator(),","                    sampler: OTel.ParentBasedSampler(rootSampler: OTel.ConstantSampler(isOn: true)),","                    processor: { group in","                        let exporter = OtlpGRPCSpanExporter(config: .init(eventLoopGroup: group))","                        return OTel.SimpleSpanProcessor(exportingTo: exporter)","                    },","                    propagator: OTel.W3CPropagator(),","                    logger: Logger(label: \"org.apodini.observe.OpenTelemetry\")","                )","","                try! otel.start().wait()","","                return (otel.tracer(), { try otel.shutdown().wait() })","            }","        ) ","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As the "},{"type":"codeVoice","code":"InstrumentConfiguration"},{"type":"text","text":" is quite complex, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" offers a separate "},{"type":"codeVoice","code":"ApodiniObserveOpenTelemetry"},{"type":"text","text":" target that dastically simplifies the configuration process for the common "},{"type":"reference","isActive":true,"identifier":"https:\/\/opentelemetry.io"},{"type":"text","text":" software stack. Add the target dependency like:"}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","    .package(url: \"https:\/\/github.com\/Apodini\/Apodini.git, from: \"<version>\")","],","targets: [","    .executableTarget(","        name: \"WebService\",","        dependencies: [","            .product(name: \"Apodini\", package: \"Apodini\"),","            .product(name: \"ApodiniObserve\", package: \"Apodini\"),","            .product(name: \"ApodiniObserveOpenTelemetry\", package: \"Apodini\")","        ]","    )","]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This then enables a way simpler configuration like:"}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import ApodiniObserveOpenTelemetry","","struct ExampleWebService: WebService {","    var content: some Component {","        \/\/ ...","    }","","    var configuration: Configuration {","        \/\/ ...","","        TracingConfiguration(","            \/\/ Either, setup tracing in Apodini using the default OpenTelemetry configuration","            .defaultOpenTelemetry(serviceName: \"ExampleWebService\"),","","            \/\/ Or, setup with exposed configuration options","            \/\/ This example shows the defaults            ","            .openTelemetryWithConfig(","                serviceName: \"ExampleWebService\",","                resourceDetection: .automatic(additionalDetectors: []),","                idGenerator: OTel.RandomIDGenerator(),","                sampler: OTel.ParentBasedSampler(rootSampler: OTel.ConstantSampler(isOn: true)),","                processor: {","                    OTel.SimpleSpanProcessor(exportingTo: OtlpGRPCSpanExporter(config: .init(eventLoopGroup: $0))","                },","                propagator: OTel.W3CPropagator(),","                logger: Logger(label: \"org.apodini.observe.OTel\")","            )","        ) ","    }","}"]},{"anchor":"Instrument","level":3,"type":"heading","text":"Instrument"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After configuration, the bootstrapped "},{"type":"codeVoice","code":"Instrument"},{"type":"text","text":"s \/ "},{"type":"codeVoice","code":"Tracer"},{"type":"text","text":"s are exposed through Apodini’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Environment"},{"type":"text","text":" property wrapper. They can be used to instrument "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"s as follows, though it is recommended to use the "},{"type":"reference","isActive":true,"identifier":"#continuous-observability"},{"type":"text","text":" capabilities of ApododiniObserve instead. The API documentation of the "},{"type":"codeVoice","code":"Instrument"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Tracer"},{"type":"text","text":" types can be found on the "},{"overridingTitleInlineContent":[{"type":"text","text":"GitHub page of swift-distributed-tracing"}],"isActive":true,"type":"reference","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing","overridingTitle":"GitHub page of swift-distributed-tracing"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["struct Greeter: Handler {  ","    @Environment(\\.instrument) var instrument","    @Environment(\\.tracer) var tracer","    @Environment(\\.connection) var connection","","    func handle() -> String {","        var baggage = Baggage.topLevel","        instrument.extract(connection.information, into: &baggage, using: HTTPInformationExtractor())","","        let span = tracer.startSpan(operationName: \"Greeter.handle()\", baggage: baggage, ofKind: .server)","        defer { span.end() }","","        return \"Hello World!\"","    }","}"]},{"anchor":"Continuous-Observability","level":2,"type":"heading","text":"Continuous Observability"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Until now, the documentation has introduced features of ApodiniObserve that enable developers to manually instrument "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"’s in order to collect observability data. However, as mentioned in the introduction, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" also offers functionalities to completly automate the instrumentation process in an "},{"type":"codeVoice","code":"Apodini"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":". This means that developers only have to specify once what telemetry data should be collected for what parts of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":", "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" will then automatically instrument these "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"s without further interactions by the developers. "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" offers a range of default observability data that can be configured to be collected and also offers the developer the ability to define own observability data that should be colleced for the entire or parts of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":"."}]},{"anchor":"Logging--Metrics","level":3,"type":"heading","text":"Logging & Metrics"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The entire Logging & Metrics automated instrumentation process is realized via a "},{"type":"codeVoice","code":"RecordingHandler"},{"type":"text","text":", which can be thought of as a wrapper around a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":". Instead of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" itself, the "},{"type":"codeVoice","code":"RecordingHandler"},{"type":"text","text":" is executed, which collects telemetry information before and after the execution of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":". Furthermore, in case of an exception, the "},{"type":"codeVoice","code":"RecordingHandler"},{"type":"text","text":" also is able to collect observability data."},{"type":"text","text":" "},{"type":"text","text":"Before the incoming "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Request"},{"type":"text","text":" is processed by the evaluation of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":", so-called "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" are executed. For example, they start the timer of a response time metric or create a log entry informing the developer about each incoming "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Request"},{"type":"text","text":". Then, the application logic in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" is executed. Depending on the outcome of this evaluation, the “normal” "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" or the exception "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" are executed. These are able to share information with the "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" executed before the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" evaluation, for example, to stop and persist a response time metric. Additionally, as it is sometimes important for the instrumentation decision to access context information about the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"’s evaluation, metadata is passed to the "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The functionality is visualized in the figure below."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"RecordingHandler.png"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This process enables developers to instrument "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"’s without actually adapting their application logic. To use this feature, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" provides developers with a "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifier that can be attached to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"’s. Within the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"-tree of an "},{"type":"codeVoice","code":"Apodini"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":", the developer is able to specify for what "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"’s, so parts of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":", which observability data should be collected. If the "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifier is attached to a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Group"},{"type":"text","text":", as can be seen in the code example below, it will automatically be passed into the nested "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"’s or "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"’s. This also means that a "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifier attached to "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"’s outside is overwritten by "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifiers further inside. The developer is able to pinpoint what part of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService"},{"type":"text","text":" should be automatically observed without repeating the "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifier for every "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Furthermore, the developer is able to specify what data should automatically be collected. By default, "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":" provides a range of "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":". These closures can then be passed as an enumeration argument to the "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifier. The three default "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" available are:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":".responseTime:"}]},{"type":"text","text":" Measures the response time of each "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" evaluation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":".errorRate:"}]},{"type":"text","text":" Instruments the error rate of each "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" execution"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":".requestCounter:"}]},{"type":"text","text":" Collects the number of requests to a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":" in a certain time frame"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" listed above can also be summarized with the "},{"type":"strong","inlineContent":[{"type":"text","text":".all"}]},{"type":"text","text":" enumeration case and passed as an argument to the "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifier."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition to the default "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":", the developer can write their own "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" by implementing a "},{"type":"codeVoice","code":"Recorder"},{"type":"text","text":". A "},{"type":"codeVoice","code":"Recorder"},{"type":"text","text":" needs to implement a "},{"type":"codeVoice","code":"before"},{"type":"text","text":", "},{"type":"codeVoice","code":"after"},{"type":"text","text":", and "},{"type":"codeVoice","code":"afterException"},{"type":"text","text":" "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" array. Each closure is passed metadata and a relay dictionary to give developers the tools necessary to sufficiently instrument the code. The implemented "},{"type":"codeVoice","code":"ExampleRecorder"},{"type":"text","text":" can then be simply added to default "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" of "},{"type":"codeVoice","code":"ApodiniObserve"},{"type":"text","text":", allowing for easy extensibility. As described before, the "},{"type":"codeVoice","code":"record"},{"type":"text","text":" modifiers are passed into the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"-tree and overwrite each other, meaning that in this example, for "},{"type":"codeVoice","code":"GreeterA"},{"type":"text","text":" the "},{"type":"codeVoice","code":"responseTime"},{"type":"text","text":" as well as the "},{"type":"codeVoice","code":"ExampleRecorder"},{"type":"text","text":" "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" are executed, whilst for "},{"type":"codeVoice","code":"GreeterB"},{"type":"text","text":" all default "},{"type":"codeVoice","code":"RecordingClosures"},{"type":"text","text":" are executed, but not the "},{"type":"codeVoice","code":"ExampleRecorder"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","","struct ExampleWebService: WebService {","    var content: some Component {","        Group(\"test\") {","            GreeterA()","                .record(.responseTime + ExampleRecorder())","            GreeterB()","        }.record(.all)","    }","}","","struct ExampleRecorder: Recorder {","    var before: [BeforeRecordingClosure] =","        [","            { observeMetadata, loggingMetadata, relay in","                \/\/ Record observability data","            }","        ]","    ","    \/\/ Optional recording closures, automatically default to an empty array","    var after: [AfterRecordingClosure] = []","    var afterException: [AfterExceptionRecordingClosure] = []","}"]},{"anchor":"Tracing","level":3,"type":"heading","text":"Tracing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Automated tracing of "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":"s is realized, similarly to Logging & Metrics, using Apodini’s "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Delegate"},{"type":"text","text":" mechanism. Any "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" can be wrapped inside a "},{"type":"codeVoice","code":"TracingHandler"},{"type":"text","text":" which handles interaction with swift-distributed-tracing’s "},{"type":"codeVoice","code":"InstrumentationSystem"},{"type":"text","text":". The handler traces the delegate handler as follows:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extract "},{"type":"codeVoice","code":"Baggage"},{"type":"text","text":" from the handler’s connection"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Start a "},{"type":"codeVoice","code":"Span"},{"type":"text","text":" using the "},{"type":"codeVoice","code":"Baggage"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Set span attributes from ApodiniObserve’s "},{"type":"codeVoice","code":"ObserveMetadata"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Handle the request using the delegate, injecting the "},{"type":"codeVoice","code":"Span"},{"type":"text","text":" as an "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/EnvironmentObject"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a "},{"type":"codeVoice","code":"ErrorType.serverError"},{"type":"text","text":", "},{"type":"codeVoice","code":"ErrorType.notAvailable"},{"type":"text","text":", or "},{"type":"codeVoice","code":"ErrorType.other"},{"type":"text","text":" error occured during request handling, the span’s status, error and additional attributes are set from the "},{"type":"codeVoice","code":"LoggingMetadata"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If a any other error occured during request handling, only the span’s status and error attributes are set."}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"End the "},{"type":"codeVoice","code":"Span"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The automated tracing can be configured on a per-"},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":" level using the "},{"type":"codeVoice","code":"TracingMetadata"},{"type":"text","text":" (typealias "},{"type":"codeVoice","code":"Tracing"},{"type":"text","text":" in the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/ComponentMetadataNamespace"},{"type":"text","text":"). Additionally, the "},{"type":"codeVoice","code":".trace(isEnabled:)"},{"type":"text","text":" modifier can be used. The following example shows how tracing can be enabled on a component and how the injected "},{"type":"codeVoice","code":"Span"},{"type":"text","text":" can be passed on to facilitate distributed tracing."}]},{"type":"codeListing","syntax":"swift","code":["import Apodini","import ApodiniObserve","import Tracing","","struct ExampleWebService: WebService {","    \/\/ ...configuration","","    var content: some Component {","        Group(\"greeter\") {","            Greeter()","        }.trace()","    }","}","","struct Greeter: Handler {","    @Environment(\\.databaseService) var databaseService","    @EnvironmentObject var span: Span","","    func handle() async throws -> String {","        let name = databaseService.getName(baggage: span.baggage)","        return \"Hello, \\(name)!\"","    }","}"]}]}],"variants":[{"paths":["\/documentation\/apodini\/observe"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Apodini\/documentation\/Apodini\/Observe","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Instrument an Apodini web service to make it observable."}],"kind":"article","metadata":{"modules":[{"name":"Apodini"}],"role":"collectionGroup","title":"Observe a web service"},"hierarchy":{"paths":[["doc:\/\/Apodini\/documentation\/Apodini"]]},"topicSections":[{"title":"Apodini","identifiers":["doc:\/\/Apodini\/documentation\/Apodini\/WebService","doc:\/\/Apodini\/documentation\/Apodini\/Component","doc:\/\/Apodini\/documentation\/Apodini\/Handler","doc:\/\/Apodini\/documentation\/Apodini\/DynamicProperty","doc:\/\/Apodini\/documentation\/Apodini\/Request","doc:\/\/Apodini\/documentation\/Apodini\/Connection","doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter","doc:\/\/Apodini\/documentation\/Apodini\/Endpoint","doc:\/\/Apodini\/documentation\/Apodini\/Information"]}],"references":{"doc://Apodini/documentation/Apodini/Jobs":{"role":"collectionGroup","title":"Jobs","abstract":[{"type":"text","text":"A guide to schedule repeating tasks in Apodini."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Jobs","kind":"article","type":"topic","url":"\/documentation\/apodini\/jobs"},"https://opentelemetry.io":{"title":"OpenTelemetry","titleInlineContent":[{"type":"text","text":"OpenTelemetry"}],"type":"link","identifier":"https:\/\/opentelemetry.io","url":"https:\/\/opentelemetry.io"},"https://www.elastic.co/elasticsearch":{"title":"ElasticSearch","titleInlineContent":[{"type":"text","text":"ElasticSearch"}],"type":"link","identifier":"https:\/\/www.elastic.co\/elasticsearch","url":"https:\/\/www.elastic.co\/elasticsearch"},"RecordingHandler.png":{"alt":"RecordingHandler functionality","type":"image","identifier":"RecordingHandler.png","variants":[{"url":"\/images\/RecordingHandler.png","traits":["1x","light"]}]},"doc://Apodini/documentation/Apodini/ComponentMetadataNamespace":{"role":"symbol","title":"ComponentMetadataNamespace","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ComponentMetadataNamespace"}],"abstract":[{"type":"text","text":"The "},{"type":"codeVoice","code":"ComponentMetadataNamespace"},{"type":"text","text":" can be used to define an appropriate"},{"type":"text","text":" "},{"type":"text","text":"Name for your "},{"type":"codeVoice","code":"ComponentMetadataDefinition"},{"type":"text","text":" in a way that avoids Name collisions"},{"type":"text","text":" "},{"type":"text","text":"on the global Scope."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/ComponentMetadataNamespace","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ComponentMetadataNamespace"}],"url":"\/documentation\/apodini\/componentmetadatanamespace"},"https://www.elastic.co/logstash/":{"title":"Logstash","titleInlineContent":[{"type":"text","text":"Logstash"}],"type":"link","identifier":"https:\/\/www.elastic.co\/logstash\/","url":"https:\/\/www.elastic.co\/logstash\/"},"doc://Apodini/documentation/Apodini/Delegate":{"role":"symbol","title":"Delegate","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Delegate"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Delegate"},{"type":"text","text":" is a lazy version of "},{"type":"codeVoice","code":"DynamicProperty"},{"type":"text","text":". That is, your delegate "},{"type":"codeVoice","code":"D"},{"type":"text","text":" can wrap"},{"type":"text","text":" "},{"type":"text","text":"multiple "},{"type":"codeVoice","code":"Property"},{"type":"text","text":"s and their functionality is maintained. The "},{"type":"codeVoice","code":"Delegate"},{"type":"text","text":" type makes its wrapped"},{"type":"text","text":" "},{"type":"text","text":"instance of "},{"type":"codeVoice","code":"D"},{"type":"text","text":" discoverable to the Apodini runtime framework. Moreover, it delays initialization and verification"},{"type":"text","text":" "},{"type":"text","text":"of "},{"type":"codeVoice","code":"@Parameter"},{"type":"text","text":"s to the point where you call "},{"type":"codeVoice","code":"Delegate"},{"type":"text","text":" as a function. This enables you to decode"},{"type":"text","text":" "},{"type":"text","text":"input lazily and to do manual error handling in case decoding fails."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Delegate","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Delegate"}],"url":"\/documentation\/apodini\/delegate"},"https://github.com/apple/swift-distributed-tracing":{"title":"swift-distributed-tracing","titleInlineContent":[{"type":"text","text":"swift-distributed-tracing"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-distributed-tracing","url":"https:\/\/github.com\/apple\/swift-distributed-tracing"},"doc://Apodini/documentation/Apodini":{"role":"collection","title":"Apodini","abstract":[{"type":"text","text":"A declarative, composable framework to build web services using Swift."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini","kind":"symbol","type":"topic","url":"\/documentation\/apodini"},"doc://Apodini/documentation/Apodini/Group":{"role":"symbol","title":"Group","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Group"}],"abstract":[],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Group","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Group"}],"url":"\/documentation\/apodini\/group"},"https://www.elastic.co/elastic-stack/":{"title":"Elastic","titleInlineContent":[{"type":"text","text":"Elastic"}],"type":"link","identifier":"https:\/\/www.elastic.co\/elastic-stack\/","url":"https:\/\/www.elastic.co\/elastic-stack\/"},"https://github.com/MrLotU/SwiftPrometheus":{"title":"SwiftPrometheus","titleInlineContent":[{"type":"text","text":"SwiftPrometheus"}],"type":"link","identifier":"https:\/\/github.com\/MrLotU\/SwiftPrometheus","url":"https:\/\/github.com\/MrLotU\/SwiftPrometheus"},"https://github.com/apple/swift-metrics":{"title":"swift-metrics","titleInlineContent":[{"type":"text","text":"swift-metrics"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-metrics","url":"https:\/\/github.com\/apple\/swift-metrics"},"doc://Apodini/documentation/Apodini/WebService":{"role":"symbol","title":"WebService","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"WebService"}],"abstract":[{"type":"text","text":"Each Apodini program consists of a "},{"type":"codeVoice","code":"WebService"},{"type":"text","text":"component that is used to describe the Web API of the Web Service"}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/WebService","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"WebService"}],"url":"\/documentation\/apodini\/webservice"},"doc://Apodini/documentation/Apodini/PushNotifications":{"role":"collectionGroup","title":"Push Notifications","abstract":[{"type":"text","text":"A guide to use push notifications in Apodini."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/PushNotifications","kind":"article","type":"topic","url":"\/documentation\/apodini\/pushnotifications"},"doc://Apodini/documentation/Apodini/Handler":{"role":"symbol","title":"Handler","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Handler"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Handler"},{"type":"text","text":" is a "},{"type":"codeVoice","code":"Component"},{"type":"text","text":" which defines an endpoint and can handle requests."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Handler"}],"url":"\/documentation\/apodini\/handler"},"https://github.com/slashmo/opentelemetry-swift":{"title":"opentelemetry-swift","titleInlineContent":[{"type":"text","text":"opentelemetry-swift"}],"type":"link","identifier":"https:\/\/github.com\/slashmo\/opentelemetry-swift","url":"https:\/\/github.com\/slashmo\/opentelemetry-swift"},"doc://Apodini/documentation/Apodini/Request":{"role":"symbol","title":"Request","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Request"}],"abstract":[{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Request"},{"type":"text","text":" is a generalized wrapper around an "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter"},{"type":"text","text":"’s internal request type."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Request","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Request"}],"url":"\/documentation\/apodini\/request"},"doc://Apodini/documentation/Apodini/Information":{"role":"symbol","title":"Information","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Information"}],"abstract":[{"type":"text","text":"An "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Information"},{"type":"text","text":" can be used to map arbitrary middleware specific Metadata into Apdoini,"},{"type":"text","text":" "},{"type":"text","text":"and make them accessible inside an "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Handler"},{"type":"text","text":"."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Information","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Information"}],"url":"\/documentation\/apodini\/information"},"doc://Apodini/documentation/Apodini/Metadata":{"role":"collectionGroup","title":"Metadata","abstract":[{"type":"text","text":"Map requirements of your web service into the implementation."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Metadata","kind":"article","type":"topic","url":"\/documentation\/apodini\/metadata"},"https://github.com/Apodini/ApodiniObservePrometheus":{"title":"ApodiniObservePrometheus Swift package","titleInlineContent":[{"type":"codeVoice","code":"ApodiniObservePrometheus"},{"type":"text","text":" Swift package"}],"type":"link","identifier":"https:\/\/github.com\/Apodini\/ApodiniObservePrometheus","url":"https:\/\/github.com\/Apodini\/ApodiniObservePrometheus"},"https://github.com/apple/swift-log":{"title":"swift-log","titleInlineContent":[{"type":"text","text":"swift-log"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-log","url":"https:\/\/github.com\/apple\/swift-log"},"doc://Apodini/documentation/Apodini/InterfaceExporter":{"role":"symbol","title":"InterfaceExporter","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"InterfaceExporter"}],"abstract":[{"type":"text","text":"An "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter"},{"type":"text","text":" is a type which requires access to the web service’s structure and"},{"type":"text","text":" "},{"type":"text","text":"internals."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/InterfaceExporter","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"InterfaceExporter"}],"url":"\/documentation\/apodini\/interfaceexporter"},"doc://Apodini/documentation/Apodini/Environment":{"role":"symbol","title":"Environment","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Environment"}],"abstract":[{"type":"text","text":"A property wrapper to inject pre-defined values  to a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Environment","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Environment"}],"url":"\/documentation\/apodini\/environment"},"https://www.elastic.co/kibana/":{"title":"Kibana","titleInlineContent":[{"type":"text","text":"Kibana"}],"type":"link","identifier":"https:\/\/www.elastic.co\/kibana\/","url":"https:\/\/www.elastic.co\/kibana\/"},"https://github.com/Apodini/swift-log-elk":{"title":"swift-log-elk","titleInlineContent":[{"type":"text","text":"swift-log-elk"}],"type":"link","identifier":"https:\/\/github.com\/Apodini\/swift-log-elk","url":"https:\/\/github.com\/Apodini\/swift-log-elk"},"#continuous-observability":{"title":"Continuous Observability","titleInlineContent":[{"type":"text","text":"Continuous Observability"}],"type":"link","identifier":"#continuous-observability","url":"#continuous-observability"},"doc://Apodini/documentation/Apodini/DatabaseConnection":{"role":"collectionGroup","title":"Database Connection","abstract":[{"type":"text","text":"Connect Apodini project to a database system."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/DatabaseConnection","kind":"article","type":"topic","url":"\/documentation\/apodini\/databaseconnection"},"doc://Apodini/documentation/Apodini/Component":{"role":"symbol","title":"Component","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Component"}],"abstract":[{"type":"text","text":"A "},{"type":"codeVoice","code":"Component"},{"type":"text","text":" is the central building block of  Apodini. Each component handles a specific functionality of the Apodini web service."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Component"}],"url":"\/documentation\/apodini\/component"},"doc://Apodini/documentation/Apodini/Endpoint":{"role":"symbol","title":"Endpoint","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Endpoint"}],"abstract":[{"type":"text","text":"Models a single Endpoint which is identified by its PathComponents and its operation"}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Endpoint","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Endpoint"}],"url":"\/documentation\/apodini\/endpoint"},"doc://Apodini/documentation/Apodini/Authorization":{"role":"collectionGroup","title":"Apodini Authorization","abstract":[{"type":"text","text":"Formulate Authorization Requirements using the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Metadata"},{"type":"text","text":" system."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Authorization","kind":"article","type":"topic","url":"\/documentation\/apodini\/authorization"},"doc://Apodini/documentation/Apodini/DynamicProperty":{"role":"symbol","title":"DynamicProperty","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DynamicProperty"}],"abstract":[{"type":"codeVoice","code":"DynamicProperty"},{"type":"text","text":" allows for wrapping "},{"type":"codeVoice","code":"Property"},{"type":"text","text":"s while maintaining their functionality. By conforming a "},{"type":"codeVoice","code":"struct"},{"type":"text","text":" to "},{"type":"codeVoice","code":"DynamicProperty"},{"type":"text","text":" "},{"type":"text","text":"you make this "},{"type":"codeVoice","code":"struct"},{"type":"text","text":"’s properties discoverable to the Apodini runtime framework. This can be used to e.g. combine"},{"type":"text","text":" "},{"type":"text","text":"two property wrappers provided by the Apodini framework into one that merges their functionality"}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/DynamicProperty","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DynamicProperty"}],"url":"\/documentation\/apodini\/dynamicproperty"},"doc://Apodini/documentation/Apodini/EnvironmentObject":{"role":"symbol","title":"EnvironmentObject","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"EnvironmentObject"}],"abstract":[{"type":"text","text":"A property wrapper to inject pre-defined values  to a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Component"},{"type":"text","text":"."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/EnvironmentObject","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"EnvironmentObject"}],"url":"\/documentation\/apodini\/environmentobject"},"https://prometheus.io/":{"title":"Prometheus","titleInlineContent":[{"type":"text","text":"Prometheus"}],"type":"link","identifier":"https:\/\/prometheus.io\/","url":"https:\/\/prometheus.io\/"},"doc://Apodini/documentation/Apodini/Connection":{"role":"symbol","title":"Connection","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Connection"}],"abstract":[{"type":"text","text":"All info related to client-connections"},{"type":"text","text":" "},{"type":"text","text":"should be handled with the "},{"type":"codeVoice","code":"Connection"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Currently, this is only the state of the connection and the request."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/Connection","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Connection"}],"url":"\/documentation\/apodini\/connection"},"doc://Apodini/documentation/Apodini/OpenAPI":{"role":"article","title":"OpenAPI Interface Exporter","abstract":[{"type":"text","text":"This document provides a short introduction to using the "},{"type":"codeVoice","code":"OpenAPIInterfaceExporter"},{"type":"text","text":", a static exporter for Apodini."},{"type":"text","text":" "},{"type":"text","text":"It can be used to expose an OpenAPI specification (version 3.0.3) for an exported RESTful API, as done by the "},{"type":"codeVoice","code":"RESTInterfaceExporter"},{"type":"text","text":"."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/OpenAPI","kind":"article","type":"topic","url":"\/documentation\/apodini\/openapi"}}}