{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Apodini supports additional test vectors, enabling us to verify that certain expressions"},{"type":"text","text":" "},{"type":"text","text":"result in a compile time error, something you can’t do with your standard testing framework."},{"type":"text","text":" "},{"type":"text","text":"Such testing is especially useful for the development of internal domain-specific languages using ‘@resultBuilder’s."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Such tests targets are called "},{"type":"strong","inlineContent":[{"type":"text","text":"Negative Compile Tests"}]},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"In those test targets you can place code that deliberately does not compile (while annotating what lines do not compile"},{"type":"text","text":" "},{"type":"text","text":"and what compiler error is expected)."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"NegativeCompileTestsRunner"},{"type":"text","text":" test target — a test target which integrates with the XCTest to boostrap the execution"},{"type":"text","text":" "},{"type":"text","text":"of Negative Compile Tests — tries to build those Negative Compile Tests targets and checks the build output"},{"type":"text","text":" "},{"type":"text","text":"and build errors to the expected compiler errors."}]},{"anchor":"Defining-a-new-Negative-Compiler-Tests-Target","level":3,"type":"heading","text":"Defining a new Negative Compiler Tests Target"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To add a new Negative Compile Test target you have to do two things:"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define a new SPM "},{"type":"codeVoice","code":".testTarget"},{"type":"text","text":" inside your "},{"type":"codeVoice","code":"Package.swift"},{"type":"text","text":" (while adding the special "},{"type":"codeVoice","code":"Cases"},{"type":"text","text":" folder the list of excluded source files)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Configure your Target inside "},{"type":"codeVoice","code":"NegativeCompileTestsRunner\/configurations.swift"},{"type":"text","text":" so the Runner knows about it."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So, step 1. would look like the following:"}]},{"type":"codeListing","syntax":"swift","code":[".testTarget(","    name: \"ExampleTargetNegativeCompileTests\",","    exclude: [\"Cases\"]",")"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Step 2.:"}]},{"type":"codeListing","syntax":"swift","code":["let configurations: TestRunnerConfiguration = [","    .target(name: \"ExampleTargetNegativeCompileTests\")","]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Lastly you want to create two files inside your test target: the "},{"type":"codeVoice","code":"Cases"},{"type":"text","text":" folder and an empty source file in the root"},{"type":"text","text":" "},{"type":"text","text":"of the target (preferably called "},{"type":"codeVoice","code":"Empty.swift"},{"type":"text","text":"; this is used to make the compiler stop complain about an empty target)."}]},{"anchor":"Create-Test-Cases-inside-your-Test-Target","level":3,"type":"heading","text":"Create Test Cases inside your Test Target"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once the target is set up, you can define your test cases inside the "},{"type":"codeVoice","code":"Cases"},{"type":"text","text":" folder, either by playing a source file"},{"type":"text","text":" "},{"type":"text","text":"directly into the "},{"type":"codeVoice","code":"Cases"},{"type":"text","text":" folder, or by creating subdirectories."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can then start writing source files which deliberately do not compile."},{"type":"text","text":" "},{"type":"text","text":"In order for the Runner to be able to validate that all of the expected compiler errors did in fact fire and that"},{"type":"text","text":" "},{"type":"text","text":"nothing more than the expected compiler errors occurred, you need to declare each an every expected compiler error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You do this by adding special comments above the line which contains the error."},{"type":"text","text":" "},{"type":"text","text":"Adhere to the following format: "},{"type":"codeVoice","code":"\/\/ error: <message>"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An example compiler error declaration might look like the following:"}]},{"type":"codeListing","syntax":"swift","code":["var i = 0","\/\/ error: cannot find operator '++' in scope; did you mean '+= 1'?","i++"]},{"anchor":"Note-to-CI-maintainers","level":3,"type":"heading","text":"Note to CI maintainers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"NegativeCompileTestsRunner"},{"type":"text","text":" is built around executing a "},{"type":"codeVoice","code":"swift build"},{"type":"text","text":" command and parsing the build output."},{"type":"text","text":" "},{"type":"text","text":"In order to avoid unnecessary recompilations (and sometimes "},{"type":"codeVoice","code":"swift build"},{"type":"text","text":" seemingly strips some build output if"},{"type":"text","text":" "},{"type":"text","text":"compiling many files) the "},{"type":"codeVoice","code":"swift build"},{"type":"text","text":" should pass the same compiler arguments as the original compilation"},{"type":"text","text":" "},{"type":"text","text":"the XCTest case was executed with (e.g. when doing "},{"type":"codeVoice","code":"swift test -Xswiftc -DEXAMPLE"},{"type":"text","text":" it defines the "},{"type":"codeVoice","code":"EXAMPLE"},{"type":"text","text":" "},{"type":"text","text":"Active Compilation Flag and the "},{"type":"codeVoice","code":"swift build"},{"type":"text","text":" command executed within the runner should reflect those same flags)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can’t detect from within the runnable with which flags the file was compiled with."},{"type":"text","text":" "},{"type":"text","text":"Though we can cover the most used ones within our current CI setup."},{"type":"text","text":" "},{"type":"text","text":"Those are:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"DEBUG"},{"type":"text","text":" is "},{"type":"strong","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" set, we assume compilation was done in release configuration and therefore append "},{"type":"codeVoice","code":"-c release"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If run on linux platform we assume test discovery was enabled an append "},{"type":"codeVoice","code":"--enable-test-discovery"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"When using the "},{"type":"codeVoice","code":"--enable-code-coverage"},{"type":"text","text":" flag we require that the Active Compilation Condition "},{"type":"codeVoice","code":"COVERAGE"},{"type":"text","text":" is also"},{"type":"text","text":" "},{"type":"text","text":"set by supplying "},{"type":"codeVoice","code":"-Xswiftc -DCOVERAGE"},{"type":"text","text":". When detecting "},{"type":"codeVoice","code":"COVERAGE"},{"type":"text","text":" we therefore"},{"type":"text","text":" "},{"type":"text","text":"append "},{"type":"codeVoice","code":"--enable-code-coverage -Xswiftc -DCOVERAGE"}]}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/apodini\/negativecompiletest"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/Apodini\/documentation\/Apodini\/NegativeCompileTest","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Defining new test target to verify certain expressions in a compile time error."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Negative Compile Test","role":"collectionGroup","modules":[{"name":"Apodini"}]},"hierarchy":{"paths":[["doc:\/\/Apodini\/documentation\/Apodini","doc:\/\/Apodini\/documentation\/Apodini\/UnitTesting"]]},"references":{"doc://Apodini/documentation/Apodini":{"role":"collection","title":"Apodini","abstract":[{"type":"text","text":"A declarative, composable framework to build web services using Swift."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini","kind":"symbol","type":"topic","url":"\/documentation\/apodini"},"doc://Apodini/documentation/Apodini/UnitTesting":{"role":"collectionGroup","title":"Unit Testing in Apodini","abstract":[{"type":"text","text":"Show how to create a typical test class for an Apodini web service."}],"identifier":"doc:\/\/Apodini\/documentation\/Apodini\/UnitTesting","kind":"article","type":"topic","url":"\/documentation\/apodini\/unittesting"}}}