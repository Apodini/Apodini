//                   
// This source file is part of the Apodini open source project
//
// SPDX-FileCopyrightText: 2019-2021 Paul Schmiedmayer and the Apodini project authors (see CONTRIBUTORS.md) <paul.schmiedmayer@tum.de>
//
// SPDX-License-Identifier: MIT
//              

import ApodiniUtils
import Logging
import Foundation
import SotoCore


enum Context {
    static let dockerBin = _findExecutable("docker")
    static let zipBin = _findExecutable("zip")
    static let logger = Logger(label: "de.lukaskollmer.ApodiniLambda")
    
    @available(
        swift,
        deprecated: 5.6,
        message: "Workaround as Bundle.module doesn't work on Swift 5.5 in Xcode. Check if this is checked in a future Swift version"
    )
    static var resourcesBundle: Bundle {
        #if swift(>=5.5) && Xcode
        // Returns the resource bundle associated with the current Swift module as generated by the Swift compiler
        class BundleFinder {}
        
        let bundleName = "Apodini_DeploymentTargetAWSLambda"
        
        let candidates = [
            // Bundle should be present here when the package is linked into an App.
            Bundle.main.resourceURL,

            // Bundle should be present here when the package is linked into a framework.
            Bundle(for: BundleFinder.self).resourceURL,

            // For command-line tools.
            Bundle.main.bundleURL
        ]

        for candidate in candidates {
            let bundlePath = candidate?.appendingPathComponent(bundleName + ".bundle")
            if let bundle = bundlePath.flatMap(Bundle.init(url:)) {
                return bundle
            }
        }
        fatalError("unable to find bundle named Apodini_DeploymentTargetAWSLambda")
        #else
        return Bundle.module
        #endif
    }
    
    
    static func makeError(code: Int = 0, _ message: String) -> Swift.Error {
        NSError(domain: "LambdaDeploy", code: code, userInfo: [
            NSLocalizedDescriptionKey: message
        ])
    }
    
    static func makeAWSCredentialProviderFactory(profileName: String?) -> SotoCore.CredentialProviderFactory {
        if let profileName = profileName {
            return .configFile(profile: profileName)
        } else if let credentials = readAwsCredentialsFromEnvironment() {
            return .static(accessKeyId: credentials.accessKeyId, secretAccessKey: credentials.secretAccessKey)
        } else {
            // if no profile name was explicitly specified, and we also were unable
            // to find credentials in the environment variables, we fall back to the "default" profile
            return .configFile(profile: "default")
        }
    }
    
    private static func readAwsCredentialsFromEnvironment() -> (accessKeyId: String, secretAccessKey: String)? {
        let env = ProcessInfo.processInfo.environment
        if let accessKey = env["AWS_ACCESS_KEY_ID"], let secretAccessKey = env["AWS_SECRET_ACCESS_KEY"] {
            return (accessKey, secretAccessKey)
        } else {
            return nil
        }
    }
    
    private static func _findExecutable(_ name: String) -> URL {
        guard let url = ChildProcess.findExecutable(named: name) else {
            fatalError("Unable to find executable '\(name)'")
        }
        return url
    }
}
