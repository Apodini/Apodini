//
//  File.swift
//  
//
//  Created by Lukas Kollmer on 2021-01-07.
//


import Foundation
import Runtime
import Apodini



extension NSError {
    public static func apodiniDeploy(code: Int = 0, localizedDescription: String) -> NSError {
        return NSError(domain: "ApodiniDeploy", code: code, userInfo: [
            NSLocalizedDescriptionKey: localizedDescription
        ])
    }
}



//public protocol DeploymentConfigInput: Codable {}



// TODO its important to somehow indicate here that these are the **user-provided** configurations written w/in the DSL.
// And that they are NOT the configurations generated by the deployment provider.




public protocol old_DeploymentConfigProvider {
    var deploymentConfig: DeploymentConfig { get }
}


public extension old_DeploymentConfigProvider {
    var deploymentConfig: old_DeploymentConfig {
        old_DeploymentConfig()
    }
}







public struct old_DeploymentGroupsConfig: Codable {
    public enum DefaultGrouping: Int, Codable { // the cases here need better names
        /// Every handler which is not explicitly put in a group will get its own group
        case separateNodes
        /// All handlers which are not explicitly put into a group will be put into a single group
        case singleNode
    }
    
    public struct Group: Codable {
        public let id: String
        public let handlerIds: [String] // strongly-type this!
        
        public init(id: String = UUID().uuidString, handlerIds: [String]) {
            self.id = id
            self.handlerIds = handlerIds
        }
    }
    
    public let defaultGrouping: DefaultGrouping
    public let groups: [Group]
    
    public init(defaultGrouping: DefaultGrouping, groups: [Group] = []) {
        self.defaultGrouping = defaultGrouping
        self.groups = groups
    }
}




// TODO ideally this would, either completely or in parts, be replaces by some DSL-like thing, if only because it looks cooler.
// we're not there yet. maybe in the future.
// there are, in fact, advantages to _not_ using a function builder here. eg when using a function builder, it'd be more difficult to define the broad structure of the config object being created here. (what can contain what, what can appear how many times, etc etc)

public struct old_DeploymentConfig: Codable {
    public let deploymentGroups: old_DeploymentGroupsConfig
    
    public init( // the important thing here is that the object must (should) be default-initializable, ie all params should have a default value
        deploymentGroups: old_DeploymentGroupsConfig = .init(defaultGrouping: .separateNodes)
    ) {
        self.deploymentGroups = deploymentGroups
    }
}




public struct HandlerTypeIdentifier: Codable, Hashable, Equatable {
    private let rawValue: String
    
    public init<H: Handler>(_: H.Type) {
        self.rawValue = "\(H.self)"
    }
    
    public init(from decoder: Decoder) throws {
        rawValue = try decoder.singleValueContainer().decode(String.self)
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(rawValue)
    }
    
    
    public static func == <H: Handler> (lhs: HandlerTypeIdentifier, rhs: H.Type) -> Bool {
        lhs == HandlerTypeIdentifier(rhs)
    }
    
    public static func == <H: Handler> (lhs: H.Type, rhs: HandlerTypeIdentifier) -> Bool {
        HandlerTypeIdentifier(lhs) == rhs
    }
}






// TODO rename to smth like DeploymentGroupInput? this isn't the actual deployment group, just the input collected from the user, which will later be used to create the proper deployment group
public struct DeploymentGroup: Codable, Hashable, Equatable {
    public typealias ID = String
    
    public let id: ID
    public let handlerTypes: Set<HandlerTypeIdentifier>
    public let handlerIds: Set<AnyHandlerIdentifier>
    
    public init(id: ID? = nil, handlerTypes: Set<HandlerTypeIdentifier>, handlerIds: Set<AnyHandlerIdentifier>) {
        self.id = id ?? Self.generateGroupId()
        self.handlerTypes = handlerTypes
        self.handlerIds = handlerIds
    }
    
    public static func generateGroupId() -> ID {
        UUID().uuidString
    }
}


public struct DeploymentGroupsConfig: Codable {
    public enum DefaultGrouping: Int, Codable { // the cases here need better names
        /// Every handler which is not explicitly put in a group will get its own group
        case separateNodes
        /// All handlers which are not explicitly put into a group will be put into a single group
        case singleNode
    }
    public let defaultGrouping: DefaultGrouping
    public let groups: Set<DeploymentGroup>
    
    public init(defaultGrouping: DefaultGrouping = .separateNodes, groups: Set<DeploymentGroup> = []) { // TODO what would be a reasonanle default?
        self.defaultGrouping = defaultGrouping
        self.groups = groups
    }
}



public struct DeploymentConfig: Codable {
    public let deploymentGroups: DeploymentGroupsConfig
    
    public init(deploymentGroups: DeploymentGroupsConfig = .init()) {
        self.deploymentGroups = deploymentGroups
    }
}





//public protocol DeploymentConfigProvider {
//    var deploymentConfig: DeploymentConfig { get }
//}
//
//
//public extension DeploymentConfigProvider {
//    var deploymentConfig: DeploymentConfig {
//        DeploymentConfig()
//    }
//}





//@_functionBuilder
//public enum CollectedHandlerConfigOptionArrayBuilder {
//    ////    public static func buildBlock(_ configurations: DeploymentConfigInput...) -> [DeploymentConfigInput] {
//    ////        configurations
//    ////    }
//}




//
//
//open class CustomDeploymentOption<DeploymentProviderHandle> {
//    let handleType: DeploymentProviderHandle.Type
//
//    public init() {
//        handleType = DeploymentProviderHandle.self
//    }
//}
//
//
//public class LambdaOptionsHandle {}
//
//
//
//public class LambdaOptionMemory: CustomDeploymentOption<LambdaOptionsHandle> {
//    let amount: Int // requested memory amount, in mb
//
//    init(amount: Int) {
//        self.amount = amount
//        super.init()
//    }
//}
//


//@_functionBuilder
//public enum CustomOptionsFunctionBuilder


//// MARK: Function Builder
//
//@_functionBuilder
//public enum DeploymentConfigBuilder {
////    public static func buildBlock(_ configurations: DeploymentConfigInput...) -> [DeploymentConfigInput] {
////        configurations
////    }
//
//    public static func buildBlock<C0: DeploymentConfigInput>(_ arg0: C0) -> [DeploymentConfigInput] {
//        return [arg0]
//    }
//
////    public static func buildEither<C: DeploymentConfigInput>(first: C) -> C {
////        first
////    }
////
////    public static func buildEither<C: DeploymentConfigInput>(second: C) -> C {
////        second
////    }
////
////    public static func buildIf<C: DeploymentConfigInput>(_ configuration: C?) -> C? {
////        configuration
////    }
//}
