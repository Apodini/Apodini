//
//  File.swift
//  
//
//  Created by Lukas Kollmer on 2021-01-07.
//


import Foundation


//public protocol DeploymentConfigInput: Codable {}



// TODO its important to somehow indicate here that these are the **user-provided** configurations written w/in the DSL.
// And that they are NOT the configurations generated by the deployment provider.




public protocol DeploymentConfigProvider {
    var deploymentConfig: DeploymentConfig { get }
}


public extension DeploymentConfigProvider {
    var deploymentConfig: DeploymentConfig {
        DeploymentConfig()
    }
}







public struct DeploymentGroupsConfig: Codable {
    public enum DefaultGrouping: Int, Codable { // the cases here need better names
        /// Every handler which is not explicitly put in a group will get its own group
        case separateNodes
        /// All handlers which are not explicitly put into a group will be put into a single group
        case singleNode
    }
    
    public struct Group: Codable {
        public let id: String
        public let handlerIds: [String] // strongly-type this!
        
        public init(id: String = UUID().uuidString, handlerIds: [String]) {
            self.id = id
            self.handlerIds = handlerIds
        }
    }
    
    public let defaultGrouping: DefaultGrouping
    public let groups: [Group]
    
    public init(defaultGrouping: DefaultGrouping, groups: [Group] = []) {
        self.defaultGrouping = defaultGrouping
        self.groups = groups
    }
}




// TODO ideally this would, either completely or in parts, be replaces by some DSL-like thing, if only because it looks cooler.
// we're not there yet. maybe in the future.
// there are, in fact, advantages to _not_ using a function builder here. eg when using a function builder, it'd be more difficult to define the broad structure of the config object being created here. (what can contain what, what can appear how many times, etc etc)

public struct DeploymentConfig: Codable {
    public let deploymentGroups: DeploymentGroupsConfig
    
    public init( // the important thing here is that the object must (should) be default-initializable, ie all params should have a default value
        deploymentGroups: DeploymentGroupsConfig = .init(defaultGrouping: .separateNodes)
    ) {
        self.deploymentGroups = deploymentGroups
    }
}




//@_functionBuilder
//public enum CollectedHandlerConfigOptionArrayBuilder {
//    ////    public static func buildBlock(_ configurations: DeploymentConfigInput...) -> [DeploymentConfigInput] {
//    ////        configurations
//    ////    }
//}




//
//
//open class CustomDeploymentOption<DeploymentProviderHandle> {
//    let handleType: DeploymentProviderHandle.Type
//
//    public init() {
//        handleType = DeploymentProviderHandle.self
//    }
//}
//
//
//public class LambdaOptionsHandle {}
//
//
//
//public class LambdaOptionMemory: CustomDeploymentOption<LambdaOptionsHandle> {
//    let amount: Int // requested memory amount, in mb
//
//    init(amount: Int) {
//        self.amount = amount
//        super.init()
//    }
//}
//


//@_functionBuilder
//public enum CustomOptionsFunctionBuilder


//// MARK: Function Builder
//
//@_functionBuilder
//public enum DeploymentConfigBuilder {
////    public static func buildBlock(_ configurations: DeploymentConfigInput...) -> [DeploymentConfigInput] {
////        configurations
////    }
//
//    public static func buildBlock<C0: DeploymentConfigInput>(_ arg0: C0) -> [DeploymentConfigInput] {
//        return [arg0]
//    }
//
////    public static func buildEither<C: DeploymentConfigInput>(first: C) -> C {
////        first
////    }
////
////    public static func buildEither<C: DeploymentConfigInput>(second: C) -> C {
////        second
////    }
////
////    public static func buildIf<C: DeploymentConfigInput>(_ configuration: C?) -> C? {
////        configuration
////    }
//}
